{
  "ggml/src/gguf.cpp": "@@ -347,25 +347,28 @@ struct gguf_context * gguf_init_from_file_impl(FILE * file, struct gguf_init_par\n     int64_t n_tensors = 0;\n \n     if (ok && gr.read(ctx->version)) {\n+        if (ok && ctx->version == 0) {\n+            GGML_LOG_ERROR(\"%s: bad GGUF version: %\" PRIu32 \"\\n\", __func__, ctx->version);\n+            ok = false;\n+        }\n+\n         /*\n          * bit layout is different when reading non-native endian models.\n          * assuming that the GGUF version is 3, the non-native endian model\n          * would read it as 0x30000000. we can use the AND operation against\n          * the last 4 hexadecimal digits to check if the model is the same\n          * endianness as the host system.\n         */\n-        if ((ctx->version & 0x0000FFFF) == 0x00000000) {\n+        if (ok && (ctx->version & 0x0000FFFF) == 0x00000000) {\n             GGML_LOG_ERROR(\"%s: failed to load model: this GGUF file version %\" PRIu32 \" is extremely large, is there a mismatch between the host and model endianness?\\n\", __func__, ctx->version);\n-            gguf_free(ctx);\n-            return nullptr;\n+            ok = false;\n         }\n \n-        GGML_ASSERT(ctx->version > 0 && ctx->version <= 65535);\n-        if (ctx->version == 1) {\n+        if (ok && ctx->version == 1) {\n             GGML_LOG_ERROR(\"%s: GGUFv1 is no longer supported, please use a more up-to-date version\\n\", __func__);\n             ok = false;\n         }\n-        if (ctx->version > GGUF_VERSION) {\n+        if (ok && ctx->version > GGUF_VERSION) {\n             GGML_LOG_ERROR(\"%s: this GGUF file is version %\" PRIu32 \" but this software only supports up to version %d\\n\",\n                 __func__, ctx->version, GGUF_VERSION);\n             ok = false;",
  "tests/test-gguf.cpp": "@@ -16,6 +16,7 @@ constexpr int offset_has_data    = 3000;\n \n enum handcrafted_file_type {\n     HANDCRAFTED_HEADER_BAD_MAGIC           =  10,\n+    HANDCRAFTED_HEADER_BAD_VERSION_0       =  15,\n     HANDCRAFTED_HEADER_BAD_VERSION_1       =  20,\n     HANDCRAFTED_HEADER_BAD_VERSION_FUTURE  =  30,\n     HANDCRAFTED_HEADER_BAD_N_TENSORS       =  40,\n@@ -51,6 +52,7 @@ enum handcrafted_file_type {\n static std::string handcrafted_file_type_name(const enum handcrafted_file_type hft) {\n     switch (hft) {\n         case HANDCRAFTED_HEADER_BAD_MAGIC:           return \"HEADER_BAD_MAGIC\";\n+        case HANDCRAFTED_HEADER_BAD_VERSION_0:       return \"HEADER_BAD_VERSION_0\";\n         case HANDCRAFTED_HEADER_BAD_VERSION_1:       return \"HEADER_BAD_VERSION_1\";\n         case HANDCRAFTED_HEADER_BAD_VERSION_FUTURE:  return \"HEADER_BAD_VERSION_FUTURE\";\n         case HANDCRAFTED_HEADER_BAD_N_KV:            return \"HEADER_BAD_N_KV\";\n@@ -171,7 +173,10 @@ static FILE * get_handcrafted_file(const unsigned int seed, const enum handcraft\n         helper_write(file, GGUF_MAGIC, 4);\n     }\n \n-    if (hft == HANDCRAFTED_HEADER_BAD_VERSION_1) {\n+    if (hft == HANDCRAFTED_HEADER_BAD_VERSION_0) {\n+        const uint32_t version = 0;\n+        helper_write(file, version);\n+    } else if (hft == HANDCRAFTED_HEADER_BAD_VERSION_1) {\n         const uint32_t version = 1;\n         helper_write(file, version);\n     } else if (hft == HANDCRAFTED_HEADER_BAD_VERSION_FUTURE) {\n@@ -660,6 +665,7 @@ static std::pair<int, int> test_handcrafted_file(const unsigned int seed) {\n \n     const std::vector<handcrafted_file_type> hfts = {\n         HANDCRAFTED_HEADER_BAD_MAGIC,\n+        HANDCRAFTED_HEADER_BAD_VERSION_0,\n         HANDCRAFTED_HEADER_BAD_VERSION_1,\n         HANDCRAFTED_HEADER_BAD_VERSION_FUTURE,\n         HANDCRAFTED_HEADER_BAD_N_KV,"
}