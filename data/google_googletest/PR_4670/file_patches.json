{
  "googletest/include/gtest/gtest.h": "@@ -1601,6 +1601,29 @@ AssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                    false);\n }\n \n+template <typename RawType>\n+AssertionResult CmpHelperFloatingPointNE(const char* lhs_expression,\n+                                         const char* rhs_expression,\n+                                         RawType lhs_value, RawType rhs_value) {\n+  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n+\n+  if (!lhs.AlmostEquals(rhs)) {\n+    return AssertionSuccess();\n+  }\n+\n+  ::std::stringstream lhs_ss;\n+  lhs_ss.precision(std::numeric_limits<RawType>::digits10 + 2);\n+  lhs_ss << lhs_value;\n+\n+  ::std::stringstream rhs_ss;\n+  rhs_ss.precision(std::numeric_limits<RawType>::digits10 + 2);\n+  rhs_ss << rhs_value;\n+\n+  return NeFailure(lhs_expression, rhs_expression,\n+                   StringStreamToString(&lhs_ss), StringStreamToString(&rhs_ss),\n+                   false);\n+}\n+\n // Helper function for implementing ASSERT_NEAR.\n //\n // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n@@ -1998,6 +2021,22 @@ class TestWithParam : public Test, public WithParamInterface<T> {};\n   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                       val1, val2)\n \n+#define EXPECT_FLOAT_NE(val1, val2)                                         \\\n+  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointNE<float>, \\\n+                      val1, val2)\n+\n+#define EXPECT_DOUBLE_NE(val1, val2)                                         \\\n+  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointNE<double>, \\\n+                      val1, val2)\n+\n+#define ASSERT_FLOAT_NE(val1, val2)                                         \\\n+  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointNE<float>, \\\n+                      val1, val2)\n+\n+#define ASSERT_DOUBLE_NE(val1, val2)                                         \\\n+  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointNE<double>, \\\n+                      val1, val2)\n+\n #define EXPECT_NEAR(val1, val2, abs_error)                                   \\\n   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, \\\n                       abs_error)",
  "googletest/include/gtest/internal/gtest-internal.h": "@@ -207,6 +207,12 @@ GTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                      const std::string& actual_value,\n                                      bool ignoring_case);\n \n+GTEST_API_ AssertionResult NeFailure(const char* expected_expression,\n+                                     const char* actual_expression,\n+                                     const std::string& expected_value,\n+                                     const std::string& actual_value,\n+                                     bool ignoring_case);\n+\n // Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\n GTEST_API_ std::string GetBoolAssertionFailureMessage(\n     const AssertionResult& assertion_result, const char* expression_text,",
  "googletest/src/gtest.cc": "@@ -1647,6 +1647,37 @@ AssertionResult EqFailure(const char* lhs_expression,\n   return AssertionFailure() << msg;\n }\n \n+AssertionResult NeFailure(const char* lhs_expression,\n+                          const char* rhs_expression,\n+                          const std::string& lhs_value,\n+                          const std::string& rhs_value, bool ignoring_case) {\n+  Message msg;\n+  msg << \"Expected inequality of these values:\";\n+  msg << \"\\n  \" << lhs_expression;\n+  if (lhs_value != lhs_expression) {\n+    msg << \"\\n    Which is: \" << lhs_value;\n+  }\n+  msg << \"\\n  \" << rhs_expression;\n+  if (rhs_value != rhs_expression) {\n+    msg << \"\\n    Which is: \" << rhs_value;\n+  }\n+\n+  if (ignoring_case) {\n+    msg << \"\\nIgnoring case\";\n+  }\n+\n+  if (!lhs_value.empty() && !rhs_value.empty()) {\n+    const std::vector<std::string> lhs_lines = SplitEscapedString(lhs_value);\n+    const std::vector<std::string> rhs_lines = SplitEscapedString(rhs_value);\n+    if (lhs_lines.size() > 1 || rhs_lines.size() > 1) {\n+      msg << \"\\nWith diff:\\n\"\n+          << edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);\n+    }\n+  }\n+\n+  return AssertionFailure() << msg;\n+}\n+\n // Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\n std::string GetBoolAssertionFailureMessage(\n     const AssertionResult& assertion_result, const char* expression_text,",
  "googletest/test/gtest_unittest.cc": "@@ -2826,6 +2826,10 @@ TEST_F(FloatTest, Zeros) {\n   EXPECT_FLOAT_EQ(0.0, -0.0);\n   EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_EQ(-0.0, 1.0), \"1.0\");\n   EXPECT_FATAL_FAILURE(ASSERT_FLOAT_EQ(0.0, 1.5), \"1.5\");\n+\n+  EXPECT_FLOAT_NE(-0.0, 1.0);\n+  EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_NE(-0.0,0.0), \"0.0\");\n+  EXPECT_FATAL_FAILURE(ASSERT_FLOAT_NE(-0.0, 0.0), \"0.0\");\n }\n \n // Tests comparing numbers close to 0.\n@@ -2851,18 +2855,41 @@ TEST_F(FloatTest, AlmostZeros) {\n         ASSERT_FLOAT_EQ(v.close_to_positive_zero, v.further_from_negative_zero);\n       },\n       \"v.further_from_negative_zero\");\n+\n+  EXPECT_FLOAT_NE(v.close_to_positive_zero, v.further_from_negative_zero);\n+  \n+  EXPECT_FATAL_FAILURE(\n+      {  // NOLINT\n+        ASSERT_FLOAT_NE(0.0, v.close_to_positive_zero);\n+        ASSERT_FLOAT_NE(v.close_to_negative_zero, v.close_to_positive_zero);\n+      },\n+      \"v.close_to_positive_zero\");\n+\n+  EXPECT_FATAL_FAILURE(\n+      {  // NOLINT\n+        ASSERT_FLOAT_NE(-0.0, v.close_to_negative_zero);\n+        ASSERT_FLOAT_NE(v.close_to_positive_zero, v.close_to_negative_zero);\n+      },\n+      \"v.close_to_negative_zero\");\n+\n }\n \n // Tests comparing numbers close to each other.\n TEST_F(FloatTest, SmallDiff) {\n   EXPECT_FLOAT_EQ(1.0, values_.close_to_one);\n   EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_EQ(1.0, values_.further_from_one),\n                           \"values_.further_from_one\");\n+\n+  EXPECT_FLOAT_NE(1.0, values_.further_from_one);\n+  EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_NE(1.0, values_.close_to_one), \n+                          \"values_.close_to_one\");\n }\n \n // Tests comparing numbers far apart.\n TEST_F(FloatTest, LargeDiff) {\n   EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_EQ(2.5, 3.0), \"3.0\");\n+\n+  EXPECT_FLOAT_NE(2.5, 3.5);\n }\n \n // Tests comparing with infinity.\n@@ -2920,6 +2947,12 @@ TEST_F(FloatTest, Commutative) {\n   // We already tested EXPECT_FLOAT_EQ(1.0, values_.further_from_one).\n   EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_EQ(values_.further_from_one, 1.0),\n                           \"1.0\");\n+\n+  // We already tested EXPECT_FLOAT_NE(1.0, values_.close_to_one).\n+  EXPECT_NONFATAL_FAILURE(EXPECT_FLOAT_NE(values_.close_to_one, 1.0), \"1.0\");\n+\n+  // We already tested EXPECT_FLOAT_NE(1.0, values_.further_from_one).\n+  EXPECT_FLOAT_NE(values_.further_from_one, 1.0);\n }\n \n // Tests EXPECT_NEAR.\n@@ -3007,6 +3040,10 @@ TEST_F(DoubleTest, Zeros) {\n   EXPECT_DOUBLE_EQ(0.0, -0.0);\n   EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_EQ(-0.0, 1.0), \"1.0\");\n   EXPECT_FATAL_FAILURE(ASSERT_DOUBLE_EQ(0.0, 1.0), \"1.0\");\n+\n+  EXPECT_DOUBLE_NE(-0.0, 1.0);\n+  EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_NE(-0.0, 0.0), \"0.0\");\n+  EXPECT_FATAL_FAILURE(ASSERT_DOUBLE_NE(-0.0, 0.0), \"0.0\");\n }\n \n // Tests comparing numbers close to 0.\n@@ -3033,18 +3070,44 @@ TEST_F(DoubleTest, AlmostZeros) {\n                          v.further_from_negative_zero);\n       },\n       \"v.further_from_negative_zero\");\n+\n+  EXPECT_DOUBLE_NE(v.close_to_positive_zero, v.further_from_negative_zero);\n+\n+  EXPECT_FATAL_FAILURE(\n+      {  // NOLINT\n+        ASSERT_DOUBLE_NE(0.0, \n+                         v.close_to_positive_zero);\n+        ASSERT_DOUBLE_NE(v.close_to_negative_zero, \n+                         v.close_to_positive_zero);\n+      },\n+      \"v.close_to_positive_zero\");\n+\n+  EXPECT_FATAL_FAILURE(\n+      {  // NOLINT\n+        ASSERT_DOUBLE_NE(-0.0, \n+                         v.close_to_negative_zero);\n+        ASSERT_DOUBLE_NE(v.close_to_positive_zero, \n+                         v.close_to_negative_zero);\n+      },\n+      \"v.close_to_negative_zero\");\n }\n \n // Tests comparing numbers close to each other.\n TEST_F(DoubleTest, SmallDiff) {\n   EXPECT_DOUBLE_EQ(1.0, values_.close_to_one);\n   EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_EQ(1.0, values_.further_from_one),\n                           \"values_.further_from_one\");\n+\n+  EXPECT_DOUBLE_NE(1.0, values_.further_from_one);\n+  EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_NE(1.0, values_.close_to_one),\n+                          \"values_.close_to_one\");\n }\n \n // Tests comparing numbers far apart.\n TEST_F(DoubleTest, LargeDiff) {\n   EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_EQ(2.0, 3.0), \"3.0\");\n+\n+  EXPECT_DOUBLE_NE(2.0, 3.0);\n }\n \n // Tests comparing with infinity.\n@@ -3097,6 +3160,12 @@ TEST_F(DoubleTest, Commutative) {\n   // We already tested EXPECT_DOUBLE_EQ(1.0, values_.further_from_one).\n   EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_EQ(values_.further_from_one, 1.0),\n                           \"1.0\");\n+\n+  // We already tested EXPECT_DOUBLE_NE(1.0, values_.close_to_one).\n+  EXPECT_NONFATAL_FAILURE(EXPECT_DOUBLE_NE(values_.close_to_one, 1.0), \"1.0\");\n+\n+  // We already tested EXPECT_FLOAT_NE(1.0, values_.further_from_one).\n+  EXPECT_DOUBLE_NE(values_.further_from_one, 1.0);\n }\n \n // Tests EXPECT_NEAR."
}