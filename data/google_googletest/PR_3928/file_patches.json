{
  "googlemock/src/gmock-internal-utils.cc": "@@ -180,8 +180,7 @@ GTEST_API_ void Log(LogSeverity severity, const std::string& message,\n       std::cout << \"\\n\";\n     }\n     std::cout << \"Stack trace:\\n\"\n-              << ::testing::internal::GetCurrentOsStackTraceExceptTop(\n-                     ::testing::UnitTest::GetInstance(), actual_to_skip);\n+              << ::testing::internal::GetCurrentOsStackTraceExceptTop(actual_to_skip);\n   }\n   std::cout << ::std::flush;\n }",
  "googletest/include/gtest/internal/gtest-internal.h": "@@ -829,8 +829,7 @@ class TypeParameterizedTestSuite<Fixture, internal::None, Types> {\n // For example, if Foo() calls Bar(), which in turn calls\n // GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n // the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\n-GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(UnitTest* unit_test,\n-                                                       int skip_count);\n+GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(int skip_count);\n \n // Helpers for suppressing warnings on unreachable code or constant\n // condition.",
  "googletest/src/gtest.cc": "@@ -6245,7 +6245,7 @@ void UnitTestImpl::UnshuffleTests() {\n // GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n // the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\n GTEST_NO_INLINE_ GTEST_NO_TAIL_CALL_ std::string\n-GetCurrentOsStackTraceExceptTop(UnitTest* /*unit_test*/, int skip_count) {\n+GetCurrentOsStackTraceExceptTop(int skip_count) {\n   // We pass skip_count + 1 to skip this wrapper function in addition\n   // to what the user really wants to skip.\n   return GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);",
  "googletest/test/googletest-param-test-test.cc": "@@ -821,7 +821,7 @@ TEST_F(PREFIX_WITH_MACRO(NamingTestNonParametrized),\n TEST(MacroNameing, LookupNames) {\n   std::set<std::string> know_suite_names, know_test_names;\n \n-  auto ins = testing::UnitTest::GetInstance();\n+  const auto& ins = testing::UnitTest::GetInstance();\n   int ts = 0;\n   while (const testing::TestSuite* suite = ins->GetTestSuite(ts++)) {\n     know_suite_names.insert(suite->name());\n@@ -897,7 +897,7 @@ INSTANTIATE_TEST_SUITE_P(CustomParamNameLambda, CustomLambdaNamingTest,\n                          });\n \n TEST(CustomNamingTest, CheckNameRegistry) {\n-  ::testing::UnitTest* unit_test = ::testing::UnitTest::GetInstance();\n+  const auto& unit_test = ::testing::UnitTest::GetInstance();\n   std::set<std::string> test_names;\n   for (int suite_num = 0; suite_num < unit_test->total_test_suite_count();\n        ++suite_num) {",
  "googletest/test/gtest-unittest-api_test.cc": "@@ -106,7 +106,7 @@ const int kTypedTests = 1;\n // Since tests can be run in any order, the values the accessors that track\n // test execution (such as failed_test_count) can not be predicted.\n TEST(ApiTest, UnitTestImmutableAccessorsWork) {\n-  UnitTest* unit_test = UnitTest::GetInstance();\n+  const auto& unit_test = UnitTest::GetInstance();\n \n   ASSERT_EQ(2 + kTypedTestSuites, unit_test->total_test_suite_count());\n   EXPECT_EQ(1 + kTypedTestSuites, unit_test->test_suite_to_run_count());\n@@ -224,7 +224,7 @@ TEST(DISABLED_Test, Dummy2) {}\n class FinalSuccessChecker : public Environment {\n  protected:\n   void TearDown() override {\n-    UnitTest* unit_test = UnitTest::GetInstance();\n+    const auto& unit_test = UnitTest::GetInstance();\n \n     EXPECT_EQ(1 + kTypedTestSuites, unit_test->successful_test_suite_count());\n     EXPECT_EQ(3 + kTypedTests, unit_test->successful_test_count());",
  "googletest/test/gtest_unittest.cc": "@@ -7703,7 +7703,7 @@ auto* dynamic_test = testing::RegisterTest(\n     __LINE__, []() -> DynamicUnitTestFixture* { return new DynamicTest; });\n \n TEST(RegisterTest, WasRegistered) {\n-  auto* unittest = testing::UnitTest::GetInstance();\n+  const auto& unittest = testing::UnitTest::GetInstance();\n   for (int i = 0; i < unittest->total_test_suite_count(); ++i) {\n     auto* tests = unittest->GetTestSuite(i);\n     if (tests->name() != std::string(\"DynamicUnitTestFixture\")) continue;"
}