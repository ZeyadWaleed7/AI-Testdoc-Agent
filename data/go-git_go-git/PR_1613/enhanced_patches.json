{
  "repository.go": {
    "status": "modified",
    "patch": "@@ -289,6 +289,15 @@ func PlainInit(path string, isBare bool, options ...InitOption) (*Repository, er\n \t\toFn(&o)\n \t}\n \n+\tvar err error\n+\t// go-git/go-git#1610\n+\tif !filepath.IsAbs(path) {\n+\t\tpath, err = filepath.Abs(path)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n \tif isBare {\n \t\tdot = osfs.New(path, osfs.WithBoundOS())\n \t\tinitFn = func(s *filesystem.Storage) (*Repository, error) {",
    "additions": 9,
    "deletions": 0,
    "changes": 9,
    "language": "go",
    "imports": [],
    "full_content": "package git\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"dario.cat/mergo\"\n\t\"github.com/ProtonMail/go-crypto/openpgp\"\n\t\"github.com/go-git/go-billy/v6\"\n\t\"github.com/go-git/go-billy/v6/osfs\"\n\t\"github.com/go-git/go-git/v6/config\"\n\t\"github.com/go-git/go-git/v6/internal/path_util\"\n\t\"github.com/go-git/go-git/v6/internal/revision\"\n\t\"github.com/go-git/go-git/v6/internal/url\"\n\t\"github.com/go-git/go-git/v6/plumbing\"\n\t\"github.com/go-git/go-git/v6/plumbing/cache\"\n\tformatcfg \"github.com/go-git/go-git/v6/plumbing/format/config\"\n\t\"github.com/go-git/go-git/v6/plumbing/format/packfile\"\n\t\"github.com/go-git/go-git/v6/plumbing/object\"\n\t\"github.com/go-git/go-git/v6/plumbing/storer\"\n\t\"github.com/go-git/go-git/v6/storage\"\n\t\"github.com/go-git/go-git/v6/storage/filesystem\"\n\t\"github.com/go-git/go-git/v6/storage/filesystem/dotgit\"\n\t\"github.com/go-git/go-git/v6/utils/ioutil\"\n\t\"github.com/go-git/go-git/v6/utils/trace\"\n)\n\n// GitDirName this is a special folder where all the git stuff is.\nconst GitDirName = \".git\"\n\nvar (\n\t// ErrBranchExists an error stating the specified branch already exists\n\tErrBranchExists = errors.New(\"branch already exists\")\n\t// ErrBranchNotFound an error stating the specified branch does not exist\n\tErrBranchNotFound = errors.New(\"branch not found\")\n\t// ErrTagExists an error stating the specified tag already exists\n\tErrTagExists = errors.New(\"tag already exists\")\n\t// ErrTagNotFound an error stating the specified tag does not exist\n\tErrTagNotFound = errors.New(\"tag not found\")\n\t// ErrFetching is returned when the packfile could not be downloaded\n\tErrFetching = errors.New(\"unable to fetch packfile\")\n\n\tErrInvalidReference            = errors.New(\"invalid reference, should be a tag or a branch\")\n\tErrRepositoryNotExists         = errors.New(\"repository does not exist\")\n\tErrRepositoryIncomplete        = errors.New(\"repository's commondir path does not exist\")\n\tErrRemoteNotFound              = errors.New(\"r",
    "raw_url": "https://github.com/go-git/go-git/raw/5a56c18c924f8f1cbbd6f7d0690ed7e894019747/repository.go",
    "is_test_file": false
  },
  "repository_test.go": {
    "status": "modified",
    "patch": "@@ -902,8 +902,13 @@ func (s *RepositorySuite) TestPlainOpenNotExistsDetectDotGit() {\n }\n \n func (s *RepositorySuite) TestPlainClone() {\n-\tdir, err := os.MkdirTemp(\"\", \"\")\n-\ts.NoError(err)\n+\tdir := \"rel-dir\"\n+\terr := os.Mkdir(dir, 0o755)\n+\ts.Require().NoError(err)\n+\n+\ts.T().Cleanup(func() {\n+\t\tos.RemoveAll(dir)\n+\t})\n \n \tr, err := PlainClone(dir, &CloneOptions{\n \t\tURL: s.GetBasicLocalRepositoryURL(),",
    "additions": 7,
    "deletions": 2,
    "changes": 9,
    "language": "go",
    "imports": [],
    "full_content": "package git\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tfixtures \"github.com/go-git/go-git-fixtures/v5\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/suite\"\n\n\t\"github.com/ProtonMail/go-crypto/openpgp\"\n\t\"github.com/ProtonMail/go-crypto/openpgp/armor\"\n\topenpgperr \"github.com/ProtonMail/go-crypto/openpgp/errors\"\n\n\t\"github.com/go-git/go-git/v6/config\"\n\t\"github.com/go-git/go-git/v6/plumbing\"\n\t\"github.com/go-git/go-git/v6/plumbing/cache\"\n\t\"github.com/go-git/go-git/v6/plumbing/object\"\n\t\"github.com/go-git/go-git/v6/plumbing/protocol/packp\"\n\t\"github.com/go-git/go-git/v6/plumbing/storer\"\n\t\"github.com/go-git/go-git/v6/plumbing/transport\"\n\t\"github.com/go-git/go-git/v6/storage\"\n\t\"github.com/go-git/go-git/v6/storage/filesystem\"\n\t\"github.com/go-git/go-git/v6/storage/memory\"\n\n\t\"github.com/go-git/go-billy/v6\"\n\t\"github.com/go-git/go-billy/v6/memfs\"\n\t\"github.com/go-git/go-billy/v6/osfs\"\n\t\"github.com/go-git/go-billy/v6/util\"\n)\n\ntype RepositorySuite struct {\n\tBaseSuite\n}\n\nfunc TestRepositorySuite(t *testing.T) {\n\tsuite.Run(t, new(RepositorySuite))\n}\n\nfunc (s *RepositorySuite) TestInit() {\n\tr, err := Init(memory.NewStorage(), WithWorkTree(memfs.New()))\n\ts.NoError(err)\n\ts.NotNil(r)\n\n\tcfg, err := r.Config()\n\ts.NoError(err)\n\ts.False(cfg.Core.IsBare)\n\n\t// check the HEAD to see what the default branch is\n\tcreateCommit(s, r)\n\tref, err := r.Head()\n\ts.NoError(err)\n\ts.Equal(plumbing.Master.String(), ref.Name().String())\n}\n\nfunc (s *RepositorySuite) TestInitWithOptions() {\n\tr, err := Init(memory.NewStorage(), WithWorkTree(memfs.New()),\n\t\tWithDefaultBranch(\"refs/heads/foo\"),\n\t)\n\ts.NoError(err)\n\ts.NotNil(r)\n\tcreateCommit(s, r)\n\n\tref, err := r.Head()\n\ts.NoError(err)\n\ts.Equal(\"refs/heads/foo\", ref.Name().String())\n}\n\nfunc (s *RepositorySuite) TestInitWithInvalidDefaultBranch() {\n\t_, err := Init(memory.NewStorage(), WithWorkTree(memfs.New()),\n\t\tWithDefaultBranch(\"foo\"),\n\t)\n\ts.No",
    "raw_url": "https://github.com/go-git/go-git/raw/5a56c18c924f8f1cbbd6f7d0690ed7e894019747/repository_test.go",
    "is_test_file": true
  }
}