{
  "okhttp-sse/api/okhttp-sse.api": "@@ -1,12 +1,26 @@\n public abstract interface class okhttp3/sse/EventSource {\n+\tpublic static final field Companion Lokhttp3/sse/EventSource$Companion;\n \tpublic abstract fun cancel ()V\n+\tpublic static fun enqueue (Lokhttp3/Call;Lokhttp3/sse/EventSourceListener;)Lokhttp3/sse/EventSource;\n+\tpublic static fun process (Lokhttp3/Response;Lokhttp3/sse/EventSourceListener;)V\n \tpublic abstract fun request ()Lokhttp3/Request;\n }\n \n+public final class okhttp3/sse/EventSource$Companion {\n+\tpublic final fun enqueue (Lokhttp3/Call;Lokhttp3/sse/EventSourceListener;)Lokhttp3/sse/EventSource;\n+\tpublic final fun process (Lokhttp3/Response;Lokhttp3/sse/EventSourceListener;)V\n+}\n+\n public abstract interface class okhttp3/sse/EventSource$Factory {\n+\tpublic static final field Companion Lokhttp3/sse/EventSource$Factory$Companion;\n+\tpublic static fun create (Lokhttp3/Call$Factory;)Lokhttp3/sse/EventSource$Factory;\n \tpublic abstract fun newEventSource (Lokhttp3/Request;Lokhttp3/sse/EventSourceListener;)Lokhttp3/sse/EventSource;\n }\n \n+public final class okhttp3/sse/EventSource$Factory$Companion {\n+\tpublic final fun create (Lokhttp3/Call$Factory;)Lokhttp3/sse/EventSource$Factory;\n+}\n+\n public abstract class okhttp3/sse/EventSourceListener {\n \tpublic fun <init> ()V\n \tpublic fun onClosed (Lokhttp3/sse/EventSource;)V",
  "okhttp-sse/src/main/kotlin/okhttp3/sse/EventSource.kt": "@@ -15,7 +15,10 @@\n  */\n package okhttp3.sse\n \n+import okhttp3.Call\n import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.sse.internal.RealEventSource\n \n interface EventSource {\n   /** Returns the original request that initiated this event source. */\n@@ -37,5 +40,40 @@ interface EventSource {\n       request: Request,\n       listener: EventSourceListener,\n     ): EventSource\n+\n+    companion object {\n+      /**\n+       * Wraps a [Call.Factory] into [EventSource.Factory].\n+       */\n+      @JvmStatic\n+      @JvmName(\"create\")\n+      fun Call.Factory.asEventSourceFactory(): Factory =\n+        Factory { request, listener ->\n+          val actualRequest =\n+            if (request.header(\"Accept\") == null) {\n+              request.newBuilder().addHeader(\"Accept\", \"text/event-stream\").build()\n+            } else {\n+              request\n+            }\n+\n+          this.newCall(actualRequest).enqueueEventSource(listener)\n+        }\n+    }\n+  }\n+\n+  companion object {\n+    /**\n+     * Enqueues a [Call] and process it as [EventSource] with [listener].\n+     */\n+    @JvmStatic\n+    @JvmName(\"enqueue\")\n+    fun Call.enqueueEventSource(listener: EventSourceListener): EventSource = RealEventSource(this, listener).also(this::enqueue)\n+\n+    /**\n+     * Processes the existing response with [listener].\n+     */\n+    @JvmStatic\n+    @JvmName(\"process\")\n+    fun Response.processEventSource(listener: EventSourceListener) = RealEventSource(this, listener).processResponse(this)\n   }\n }",
  "okhttp-sse/src/main/kotlin/okhttp3/sse/EventSourceListener.kt": "@@ -29,7 +29,11 @@ abstract class EventSourceListener {\n   }\n \n   /**\n-   * TODO description.\n+   * Invoked when a new event has been sent to the client.\n+   *\n+   * @param id The `id` line of the event, might be null.\n+   * @param type The `event` line of the event, might be null.\n+   * @param data The `data` line of the event.\n    */\n   open fun onEvent(\n     eventSource: EventSource,\n@@ -40,7 +44,7 @@ abstract class EventSourceListener {\n   }\n \n   /**\n-   * TODO description.\n+   * Invoked when the HTTP connection has been closed normally.\n    *\n    * No further calls to this listener will be made.\n    */",
  "okhttp-sse/src/main/kotlin/okhttp3/sse/EventSources.kt": "@@ -18,37 +18,41 @@ package okhttp3.sse\n import okhttp3.Call\n import okhttp3.OkHttpClient\n import okhttp3.Response\n-import okhttp3.sse.internal.RealEventSource\n+import okhttp3.sse.EventSource.Companion.processEventSource\n+import okhttp3.sse.EventSource.Factory.Companion.asEventSourceFactory\n \n object EventSources {\n   @Deprecated(\n     message = \"required for binary-compatibility!\",\n     level = DeprecationLevel.HIDDEN,\n   )\n   @JvmStatic\n-  fun createFactory(client: OkHttpClient) = createFactory(client as Call.Factory)\n+  fun createFactory(client: OkHttpClient) = client.asEventSourceFactory()\n \n+  @Deprecated(\n+    message = \"Moved to extension function.\",\n+    replaceWith =\n+      ReplaceWith(\n+        expression = \"callFactory.asEventSourceFactory()\",\n+        imports = [\"okhttp3.sse.EventSource.Factory.Companion.asEventSourceFactory\"],\n+      ),\n+    level = DeprecationLevel.WARNING,\n+  )\n   @JvmStatic\n-  fun createFactory(callFactory: Call.Factory): EventSource.Factory =\n-    EventSource.Factory { request, listener ->\n-      val actualRequest =\n-        if (request.header(\"Accept\") == null) {\n-          request.newBuilder().addHeader(\"Accept\", \"text/event-stream\").build()\n-        } else {\n-          request\n-        }\n-\n-      RealEventSource(actualRequest, listener).apply {\n-        connect(callFactory)\n-      }\n-    }\n+  fun createFactory(callFactory: Call.Factory): EventSource.Factory = callFactory.asEventSourceFactory()\n \n+  @Deprecated(\n+    message = \"Moved to extension function.\",\n+    replaceWith =\n+      ReplaceWith(\n+        expression = \"response.processEventSource(listener)\",\n+        imports = [\"okhttp3.sse.EventSource.Companion.processEventSource\"],\n+      ),\n+    level = DeprecationLevel.WARNING,\n+  )\n   @JvmStatic\n   fun processResponse(\n     response: Response,\n     listener: EventSourceListener,\n-  ) {\n-    val eventSource = RealEventSource(response.request, listener)\n-    eventSource.processResponse(response)\n-  }\n+  ): Unit = response.processEventSource(listener)\n }",
  "okhttp-sse/src/main/kotlin/okhttp3/sse/internal/RealEventSource.kt": "@@ -25,22 +25,18 @@ import okhttp3.internal.stripBody\n import okhttp3.sse.EventSource\n import okhttp3.sse.EventSourceListener\n \n-internal class RealEventSource(\n+internal class RealEventSource private constructor(\n+  private val call: Call?,\n   private val request: Request,\n   private val listener: EventSourceListener,\n ) : EventSource,\n   ServerSentEventReader.Callback,\n   Callback {\n-  private var call: Call? = null\n+  constructor(call: Call, listener: EventSourceListener) : this(call, call.request(), listener)\n \n-  @Volatile private var canceled = false\n+  constructor(response: Response, listener: EventSourceListener) : this(null, response.request, listener)\n \n-  fun connect(callFactory: Call.Factory) {\n-    call =\n-      callFactory.newCall(request).apply {\n-        enqueue(this@RealEventSource)\n-      }\n-  }\n+  @Volatile private var canceled = false\n \n   override fun onResponse(\n     call: Call,\n@@ -49,7 +45,7 @@ internal class RealEventSource(\n     processResponse(response)\n   }\n \n-  fun processResponse(response: Response) {\n+  internal fun processResponse(response: Response) {\n     response.use {\n       if (!response.isSuccessful) {\n         listener.onFailure(this, null, response)",
  "okhttp-sse/src/main/kotlin/okhttp3/sse/internal/ServerSentEventReader.kt": "@@ -22,7 +22,7 @@ import okio.BufferedSource\n import okio.ByteString.Companion.encodeUtf8\n import okio.Options\n \n-class ServerSentEventReader(\n+internal class ServerSentEventReader(\n   private val source: BufferedSource,\n   private val callback: Callback,\n ) {\n@@ -119,7 +119,7 @@ class ServerSentEventReader(\n   }\n \n   companion object {\n-    val options =\n+    private val options =\n       Options.of(\n         // 0\n         \"\\r\\n\".encodeUtf8(),",
  "okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceFactoryTest.java": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (C) 2018 Square, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package okhttp3.sse.internal;\n+\n+import mockwebserver3.MockResponse;\n+import mockwebserver3.MockWebServer;\n+import mockwebserver3.junit5.StartStop;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSourceListener;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class EventSourceFactoryTest {\n+\n+  @StartStop\n+  private final MockWebServer server = new MockWebServer();\n+\n+  @Test\n+  public void testEventSourceFactory() throws Exception {\n+    OkHttpClient client = new OkHttpClient();\n+    EventSource.Factory factory = EventSource.Factory.create(client);\n+    server.enqueue(\n+      new MockResponse.Builder()\n+        .body(\"data: hello\\n\\n\")\n+        .setHeader(\"content-type\", \"text/event-stream\")\n+        .build()\n+    );\n+    Request request = new Request.Builder().url(server.url(\"/\")).build();\n+    CompletableFuture<Void> future = new CompletableFuture<>();\n+    factory.newEventSource(request, new EventSourceListener() {\n+      @Override\n+      public void onOpen(@NotNull EventSource eventSource, @NotNull Response response) {\n+        try {\n+          assertEquals(\"text/event-stream\", response.request().header(\"Accept\"));\n+        } catch (Exception e) {\n+          future.completeExceptionally(e);\n+        }\n+      }\n+\n+      @Override\n+      public void onEvent(@NotNull EventSource eventSource, @Nullable String id, @Nullable String type, @NotNull String data) {\n+        try {\n+          assertEquals(\"hello\", data);\n+          future.complete(null);\n+        } catch (Exception e) {\n+          future.completeExceptionally(e);\n+        }\n+      }\n+\n+      @Override\n+      public void onClosed(@NotNull EventSource eventSource) {\n+        future.completeExceptionally(new IllegalStateException(\"closed\"));\n+      }\n+\n+      @Override\n+      public void onFailure(@NotNull EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {\n+        future.completeExceptionally(t == null ? new NullPointerException() : t);\n+      }\n+    });\n+    future.get();\n+  }\n+\n+}",
  "okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceHttpTest.kt": "@@ -26,7 +26,7 @@ import okhttp3.OkHttpClientTestRule\n import okhttp3.RecordingEventListener\n import okhttp3.Request\n import okhttp3.sse.EventSource\n-import okhttp3.sse.EventSources.createFactory\n+import okhttp3.sse.EventSource.Factory.Companion.asEventSourceFactory\n import okhttp3.testing.PlatformRule\n import org.junit.jupiter.api.AfterEach\n import org.junit.jupiter.api.Tag\n@@ -268,7 +268,7 @@ class EventSourceHttpTest {\n       builder.header(\"Accept\", accept)\n     }\n     val request = builder.build()\n-    val factory = createFactory(client)\n+    val factory = client.asEventSourceFactory()\n     return factory.newEventSource(request, listener)\n   }\n }",
  "okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourcesHttpTest.kt": "@@ -20,7 +20,7 @@ import mockwebserver3.MockWebServer\n import mockwebserver3.junit5.StartStop\n import okhttp3.OkHttpClientTestRule\n import okhttp3.Request\n-import okhttp3.sse.EventSources.processResponse\n+import okhttp3.sse.EventSource.Companion.processEventSource\n import okhttp3.testing.PlatformRule\n import org.junit.jupiter.api.AfterEach\n import org.junit.jupiter.api.Tag\n@@ -66,7 +66,7 @@ class EventSourcesHttpTest {\n         .url(server.url(\"/\"))\n         .build()\n     val response = client.newCall(request).execute()\n-    processResponse(response, listener)\n+    response.processEventSource(listener)\n     listener.assertOpen()\n     listener.assertEvent(null, null, \"hey\")\n     listener.assertClose()\n@@ -93,7 +93,7 @@ class EventSourcesHttpTest {\n         .url(server.url(\"/\"))\n         .build()\n     val response = client.newCall(request).execute()\n-    processResponse(response, listener)\n+    response.processEventSource(listener)\n     listener.assertOpen()\n     listener.assertFailure(\"canceled\")\n   }"
}