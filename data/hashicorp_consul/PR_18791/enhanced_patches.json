{
  "test/integration/consul-container/libs/service/common.go": {
    "status": "modified",
    "patch": "@@ -9,5 +9,5 @@ import (\n \n const (\n \tenvoyLogLevel        = \"debug\"\n-\thashicorpDockerProxy = \"docker.mirror.hashicorp.services\"\n+\tHashicorpDockerProxy = \"docker.mirror.hashicorp.services\"\n )",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage service\n\nimport (\n\t_ \"embed\"\n)\n\nconst (\n\tenvoyLogLevel        = \"debug\"\n\tHashicorpDockerProxy = \"docker.mirror.hashicorp.services\"\n)\n",
    "raw_url": "https://github.com/hashicorp/consul/raw/b77e2223fa0c93dcdd358210ce0f663e4654906b/test%2Fintegration%2Fconsul-container%2Flibs%2Fservice%2Fcommon.go",
    "is_test_file": true
  },
  "test/integration/consul-container/libs/service/examples.go": {
    "status": "modified",
    "patch": "@@ -187,7 +187,7 @@ func NewExampleService(ctx context.Context, name string, httpPort int, grpcPort\n \tcommand = append(command, containerArgs...)\n \n \treq := testcontainers.ContainerRequest{\n-\t\tImage:      hashicorpDockerProxy + \"/fortio/fortio\",\n+\t\tImage:      HashicorpDockerProxy + \"/fortio/fortio\",\n \t\tWaitingFor: wait.ForLog(\"\").WithStartupTimeout(60 * time.Second),\n \t\tAutoRemove: false,\n \t\tName:       containerName,",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage service\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/testcontainers/testcontainers-go\"\n\t\"github.com/testcontainers/testcontainers-go/wait\"\n\n\t\"github.com/hashicorp/consul/api\"\n\n\tlibcluster \"github.com/hashicorp/consul/test/integration/consul-container/libs/cluster\"\n\t\"github.com/hashicorp/consul/test/integration/consul-container/libs/utils\"\n)\n\n// exampleContainer\ntype exampleContainer struct {\n\tctx         context.Context\n\tcontainer   testcontainers.Container\n\tip          string\n\thttpPort    int\n\tgrpcPort    int\n\tserviceName string\n}\n\nvar _ Service = (*exampleContainer)(nil)\n\nfunc (g exampleContainer) Exec(ctx context.Context, cmd []string) (string, error) {\n\texitCode, reader, err := g.container.Exec(ctx, cmd)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"exec with error %s\", err)\n\t}\n\tif exitCode != 0 {\n\t\treturn \"\", fmt.Errorf(\"exec with exit code %d\", exitCode)\n\t}\n\tbuf, err := io.ReadAll(reader)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"error reading from exec output: %w\", err)\n\t}\n\treturn string(buf), nil\n}\n\nfunc (g exampleContainer) Export(partition, peerName string, client *api.Client) error {\n\tconfig := &api.ExportedServicesConfigEntry{\n\t\tName: partition,\n\t\tServices: []api.ExportedService{{\n\t\t\tName: g.GetServiceName(),\n\t\t\tConsumers: []api.ServiceConsumer{\n\t\t\t\t// TODO: need to handle the changed field name in 1.13\n\t\t\t\t{Peer: peerName},\n\t\t\t},\n\t\t}},\n\t}\n\n\t_, _, err := client.ConfigEntries().Set(config, &api.WriteOptions{})\n\treturn err\n}\n\nfunc (g exampleContainer) GetAddr() (string, int) {\n\treturn g.ip, g.httpPort\n}\n\nfunc (g exampleContainer) GetAddrs() (string, []int) {\n\treturn \"\", nil\n}\n\nfunc (g exampleContainer) GetPort(port int) (int, error) {\n\treturn 0, nil\n}\n\nfunc (g exampleContainer) Restart() error {\n\treturn fmt.Errorf(\"Restart Unimplemented by ConnectContainer\")\n}\n\nfunc (g exampleContainer) GetLogs() (string, error) {\n\trc, err := g.container.Logs(g.ctx)\n\tif err != ",
    "raw_url": "https://github.com/hashicorp/consul/raw/b77e2223fa0c93dcdd358210ce0f663e4654906b/test%2Fintegration%2Fconsul-container%2Flibs%2Fservice%2Fexamples.go",
    "is_test_file": true
  },
  "test/integration/consul-container/test/gateways/gateway_endpoint_test.go": {
    "status": "modified",
    "patch": "@@ -227,6 +227,7 @@ type checkOptions struct {\n \tresponseHeaders map[string]string\n \tstatusCode      int\n \ttestName        string\n+\texpectedBody    string\n }\n \n // checkRoute, customized version of libassert.RouteEchos to allow for headers/distinguishing between the server instances\n@@ -289,8 +290,13 @@ func checkRoute(t *testing.T, port int, path string, headers map[string]string,\n \t\t\t\treturn false\n \t\t\t}\n \t\t}\n-\t\tif !strings.Contains(string(body), \"hello\") {\n-\t\t\tt.Log(\"body does not contain 'hello'\")\n+\t\texpectedBody := expected.expectedBody\n+\t\tif expectedBody == \"\" {\n+\t\t\texpectedBody = \"hello\"\n+\t\t}\n+\t\tif !strings.Contains(string(body), expectedBody) {\n+\t\t\tt.Log(string(body))\n+\t\t\tt.Log(\"body does not contain \" + expectedBody)\n \t\t\treturn false\n \t\t}\n ",
    "additions": 8,
    "deletions": 2,
    "changes": 10,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage gateways\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-cleanhttp\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/api\"\n\tlibassert \"github.com/hashicorp/consul/test/integration/consul-container/libs/assert\"\n\tlibcluster \"github.com/hashicorp/consul/test/integration/consul-container/libs/cluster\"\n\tlibservice \"github.com/hashicorp/consul/test/integration/consul-container/libs/service\"\n\tlibtopology \"github.com/hashicorp/consul/test/integration/consul-container/libs/topology\"\n)\n\n// Creates a gateway service and tests to see if it is routable\nfunc TestAPIGatewayCreate(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\tt.Parallel()\n\n\tgatewayName := randomName(\"gateway\", 16)\n\trouteName := randomName(\"route\", 16)\n\tserviceName := randomName(\"service\", 16)\n\tlistenerPortOne := 6000\n\tserviceHTTPPort := 6001\n\tserviceGRPCPort := 6002\n\n\tclusterConfig := &libtopology.ClusterConfig{\n\t\tNumServers: 1,\n\t\tNumClients: 1,\n\t\tBuildOpts: &libcluster.BuildOptions{\n\t\t\tDatacenter:             \"dc1\",\n\t\t\tInjectAutoEncryption:   true,\n\t\t\tInjectGossipEncryption: true,\n\t\t\tAllowHTTPAnyway:        true,\n\t\t},\n\t\tExposedPorts: []int{\n\t\t\tlistenerPortOne,\n\t\t\tserviceHTTPPort,\n\t\t\tserviceGRPCPort,\n\t\t},\n\t}\n\n\tcluster, _, _ := libtopology.NewCluster(t, clusterConfig)\n\tclient := cluster.APIClient(0)\n\n\tnamespace := getOrCreateNamespace(t, client)\n\n\t// Create a gateway\n\t// We intentionally do this before creating the config entries\n\tgatewayService, err := libservice.NewGatewayService(context.Background(), libservice.GatewayConfig{\n\t\tKind:      \"api\",\n\t\tNamespace: namespace,\n\t\tName:      gatewayName,\n\t}, cluster.Agents[0], listenerPortOne)\n\trequire.NoError(t, err)\n\n\t// We check this is healthy here because in the case of bringing up a new kube cluster,\n\t// it is not possible to create the config entry in advance.\n\t// The health chec",
    "raw_url": "https://github.com/hashicorp/consul/raw/b77e2223fa0c93dcdd358210ce0f663e4654906b/test%2Fintegration%2Fconsul-container%2Ftest%2Fgateways%2Fgateway_endpoint_test.go",
    "is_test_file": true
  },
  "test/integration/consul-container/test/gateways/http_route_test.go": {
    "status": "modified",
    "patch": "@@ -8,6 +8,8 @@ import (\n \t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"fmt\"\n+\t\"github.com/testcontainers/testcontainers-go\"\n+\t\"k8s.io/utils/pointer\"\n \t\"testing\"\n \t\"time\"\n \n@@ -737,3 +739,233 @@ func TestHTTPRouteParentRefChange(t *testing.T) {\n \t\t\"Host\": \"test.foo\",\n \t}, \"\")\n }\n+\n+func TestHTTPRouteRetryAndTimeout(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"too slow for testing.Short\")\n+\t}\n+\n+\tt.Parallel()\n+\n+\t// infrastructure set up\n+\tlistenerPort := 6018\n+\tretryServiceHTTPPort := 6019\n+\tretryServiceGRPCPort := 6020\n+\ttimeoutServiceHTTPPort := 6021\n+\ttimeoutServiceGRPCPort := 6022\n+\n+\tretryServiceName := randomName(\"service\", 16)\n+\tgatewayName := randomName(\"gw\", 16)\n+\tretryRouteName := randomName(\"route\", 16)\n+\ttimeoutServiceName := randomName(\"service\", 16)\n+\ttimeoutRouteName := randomName(\"route\", 16)\n+\tretryPath := \"/retry\"\n+\ttimeoutPath := \"/timeout\"\n+\n+\tclusterConfig := &libtopology.ClusterConfig{\n+\t\tNumServers: 1,\n+\t\tNumClients: 1,\n+\t\tBuildOpts: &libcluster.BuildOptions{\n+\t\t\tDatacenter:             \"dc1\",\n+\t\t\tInjectAutoEncryption:   true,\n+\t\t\tInjectGossipEncryption: true,\n+\t\t\tAllowHTTPAnyway:        true,\n+\t\t},\n+\t\tExposedPorts: []int{\n+\t\t\tlistenerPort,\n+\t\t\tretryServiceGRPCPort,\n+\t\t\tretryServiceHTTPPort,\n+\t\t\ttimeoutServiceGRPCPort,\n+\t\t\ttimeoutServiceHTTPPort,\n+\t\t},\n+\t\tApplyDefaultProxySettings: true,\n+\t}\n+\n+\tcluster, _, _ := libtopology.NewCluster(t, clusterConfig)\n+\tclient := cluster.Agents[0].GetClient()\n+\n+\tnamespace := getOrCreateNamespace(t, client)\n+\n+\t_, _, err := libservice.CreateAndRegisterCustomServiceAndSidecar(\n+\t\tcluster.Agents[0], &libservice.ServiceOpts{\n+\t\t\tID:        retryServiceName,\n+\t\t\tName:      retryServiceName,\n+\t\t\tNamespace: namespace,\n+\t\t\tHTTPPort:  retryServiceHTTPPort,\n+\t\t\tGRPCPort:  retryServiceGRPCPort,\n+\t\t},\n+\t\ttestcontainers.ContainerRequest{\n+\t\t\tImage: libservice.HashicorpDockerProxy + \"/nicholasjackson/fake-service:v0.26.0\",\n+\t\t\tEnv: map[string]string{\n+\t\t\t\t\"LISTEN_ADDR\": fmt.Sprintf(\"0.0.0.0:%d\", retryServiceHTTPPort),\n+\t\t\t\t\"ERROR_RATE\":  \"0.5\",\n+\t\t\t},\n+\t\t},\n+\t\tnil,\n+\t)\n+\trequire.NoError(t, err)\n+\n+\t_, _, err = libservice.CreateAndRegisterCustomServiceAndSidecar(\n+\t\tcluster.Agents[0], &libservice.ServiceOpts{\n+\t\t\tID:        timeoutServiceName,\n+\t\t\tName:      timeoutServiceName,\n+\t\t\tNamespace: namespace,\n+\t\t\tHTTPPort:  timeoutServiceHTTPPort,\n+\t\t\tGRPCPort:  timeoutServiceGRPCPort,\n+\t\t},\n+\t\ttestcontainers.ContainerRequest{\n+\t\t\tImage: libservice.HashicorpDockerProxy + \"/nicholasjackson/fake-service:v0.26.0\",\n+\t\t\tEnv: map[string]string{\n+\t\t\t\t\"LISTEN_ADDR\": fmt.Sprintf(\"0.0.0.0:%d\", timeoutServiceHTTPPort),\n+\t\t\t\t\"ERROR_RATE\":  \"1.0\",\n+\t\t\t\t\"ERROR_DELAY\": \"1m\",\n+\t\t\t},\n+\t\t},\n+\t\tnil,\n+\t)\n+\n+\trequire.NoError(t, err)\n+\n+\t// write config entries\n+\tproxyDefaults := &api.ProxyConfigEntry{\n+\t\tKind: api.ProxyDefaults,\n+\t\tName: api.ProxyConfigGlobal,\n+\t\tConfig: map[string]interface{}{\n+\t\t\t\"protocol\": \"http\",\n+\t\t},\n+\t}\n+\n+\trequire.NoError(t, cluster.ConfigEntryWrite(proxyDefaults))\n+\n+\tapiGateway := &api.APIGatewayConfigEntry{\n+\t\tKind: \"api-gateway\",\n+\t\tName: gatewayName,\n+\t\tListeners: []api.APIGatewayListener{\n+\t\t\t{\n+\t\t\t\tName:     \"listener\",\n+\t\t\t\tPort:     listenerPort,\n+\t\t\t\tProtocol: \"http\",\n+\t\t\t},\n+\t\t},\n+\t\tNamespace: namespace,\n+\t}\n+\n+\tretryRoute := &api.HTTPRouteConfigEntry{\n+\t\tKind:      api.HTTPRoute,\n+\t\tName:      retryRouteName,\n+\t\tNamespace: namespace,\n+\t\tParents: []api.ResourceReference{\n+\t\t\t{\n+\t\t\t\tKind:      api.APIGateway,\n+\t\t\t\tName:      gatewayName,\n+\t\t\t\tNamespace: namespace,\n+\t\t\t},\n+\t\t},\n+\t\tHostnames: []string{\n+\t\t\t\"test.foo\",\n+\t\t\t\"test.example\",\n+\t\t},\n+\t\tRules: []api.HTTPRouteRule{\n+\t\t\t{\n+\t\t\t\tFilters: api.HTTPFilters{\n+\t\t\t\t\tRetryFilter: &api.RetryFilter{\n+\t\t\t\t\t\tNumRetries:         pointer.Uint32(10),\n+\t\t\t\t\t\tRetryOnStatusCodes: []uint32{500},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tServices: []api.HTTPService{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:      retryServiceName,\n+\t\t\t\t\t\tNamespace: namespace,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tMatches: []api.HTTPMatch{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tPath: api.HTTPPathMatch{\n+\t\t\t\t\t\t\tMatch: api.HTTPPathMatchPrefix,\n+\t\t\t\t\t\t\tValue: retryPath,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\ttimeoutRoute := &api.HTTPRouteConfigEntry{\n+\t\tKind:      api.HTTPRoute,\n+\t\tName:      timeoutRouteName,\n+\t\tNamespace: namespace,\n+\t\tParents: []api.ResourceReference{\n+\t\t\t{\n+\t\t\t\tKind:      api.APIGateway,\n+\t\t\t\tName:      gatewayName,\n+\t\t\t\tNamespace: namespace,\n+\t\t\t},\n+\t\t},\n+\t\tHostnames: []string{\n+\t\t\t\"test.foo\",\n+\t\t\t\"test.example\",\n+\t\t},\n+\t\tRules: []api.HTTPRouteRule{\n+\t\t\t{\n+\t\t\t\tFilters: api.HTTPFilters{\n+\t\t\t\t\tTimeoutFilter: &api.TimeoutFilter{\n+\t\t\t\t\t\tRequestTimeout: 1,\n+\t\t\t\t\t\tIdleTimeout:    1,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tServices: []api.HTTPService{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:      timeoutServiceName,\n+\t\t\t\t\t\tNamespace: namespace,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tMatches: []api.HTTPMatch{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tPath: api.HTTPPathMatch{\n+\t\t\t\t\t\t\tMatch: api.HTTPPathMatchPrefix,\n+\t\t\t\t\t\t\tValue: timeoutPath,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\trequire.NoError(t, cluster.ConfigEntryWrite(apiGateway))\n+\trequire.NoError(t, cluster.ConfigEntryWrite(timeoutRoute))\n+\trequire.NoError(t, cluster.ConfigEntryWrite(retryRoute))\n+\n+\t// create gateway service\n+\tgwCfg := libservice.GatewayConfig{\n+\t\tName:      gatewayName,\n+\t\tKind:      \"api\",\n+\t\tNamespace: namespace,\n+\t}\n+\tgatewayService, err := libservice.NewGatewayService(context.Background(), gwCfg, cluster.Agents[0], listenerPort)\n+\trequire.NoError(t, err)\n+\tlibassert.CatalogServiceExists(t, client, gatewayName, &api.QueryOptions{Namespace: namespace})\n+\n+\t// make sure config entries have been properly created\n+\tcheckGatewayConfigEntry(t, client, gatewayName, &api.QueryOptions{Namespace: namespace})\n+\tt.Log(\"checking retry route\")\n+\tcheckHTTPRouteConfigEntry(t, client, retryRouteName, &api.QueryOptions{Namespace: namespace})\n+\n+\tt.Log(\"checking timeout route\")\n+\tcheckHTTPRouteConfigEntry(t, client, timeoutRouteName, &api.QueryOptions{Namespace: namespace})\n+\n+\t// gateway resolves routes\n+\tgatewayPort, err := gatewayService.GetPort(listenerPort)\n+\trequire.NoError(t, err)\n+\tfmt.Println(\"Gateway Port: \", gatewayPort)\n+\n+\t// hit service 1 by hitting root path\n+\tcheckRoute(t, gatewayPort, retryPath, map[string]string{\n+\t\t\"Host\": \"test.foo\",\n+\t}, checkOptions{debug: false, statusCode: 200, testName: \"retry should succeed cleanly\", expectedBody: \"Hello World\"})\n+\n+\tcheckRoute(t, gatewayPort, timeoutPath, map[string]string{\n+\t\t\"Host\": \"test.foo\",\n+\t}, checkOptions{debug: false, statusCode: 500, testName: \"timeout should timeout\", expectedBody: \"timeout\"})\n+\n+}",
    "additions": 232,
    "deletions": 0,
    "changes": 232,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage gateways\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"github.com/testcontainers/testcontainers-go\"\n\t\"k8s.io/utils/pointer\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/api\"\n\n\tlibassert \"github.com/hashicorp/consul/test/integration/consul-container/libs/assert\"\n\tlibcluster \"github.com/hashicorp/consul/test/integration/consul-container/libs/cluster\"\n\tlibservice \"github.com/hashicorp/consul/test/integration/consul-container/libs/service\"\n\tlibtopology \"github.com/hashicorp/consul/test/integration/consul-container/libs/topology\"\n)\n\n// randomName generates a random name of n length with the provided\n// prefix. If prefix is omitted, the then entire name is random char.\nfunc randomName(prefix string, n int) string {\n\tif n == 0 {\n\t\tn = 32\n\t}\n\tif len(prefix) >= n {\n\t\treturn prefix\n\t}\n\tp := make([]byte, n)\n\trand.Read(p)\n\treturn fmt.Sprintf(\"%s-%s\", prefix, hex.EncodeToString(p))[:n]\n}\n\nfunc TestHTTPRouteFlattening(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\tt.Parallel()\n\n\t// infrastructure set up\n\tlistenerPort := 6004\n\tserviceOneHTTPPort := 6005\n\tserviceOneGRPCPort := 6006\n\tserviceTwoHTTPPort := 6007\n\tserviceTwoGRPCPort := 6008\n\n\tserviceOneName := randomName(\"service\", 16)\n\tserviceTwoName := randomName(\"service\", 16)\n\tserviceOneResponseCode := 200\n\tserviceTwoResponseCode := 418\n\tgatewayName := randomName(\"gw\", 16)\n\trouteOneName := randomName(\"route\", 16)\n\trouteTwoName := randomName(\"route\", 16)\n\tfooHostName := \"test.foo\"\n\texampleHostName := \"test.example\"\n\tpath1 := \"/\"\n\tpath2 := \"/v2\"\n\n\tclusterConfig := &libtopology.ClusterConfig{\n\t\tNumServers: 1,\n\t\tNumClients: 1,\n\t\tBuildOpts: &libcluster.BuildOptions{\n\t\t\tDatacenter:             \"dc1\",\n\t\t\tInjectAutoEncryption:   true,\n\t\t\tInjectGossipEncryption: true,\n\t\t\tAllowHTTPAnyway:        true,\n\t\t},\n\t\tExposedPorts: []int{\n\t\t\tli",
    "raw_url": "https://github.com/hashicorp/consul/raw/b77e2223fa0c93dcdd358210ce0f663e4654906b/test%2Fintegration%2Fconsul-container%2Ftest%2Fgateways%2Fhttp_route_test.go",
    "is_test_file": true
  }
}