{
  "test/integration/consul-container/libs/service/common.go": "@@ -9,5 +9,5 @@ import (\n \n const (\n \tenvoyLogLevel        = \"debug\"\n-\thashicorpDockerProxy = \"docker.mirror.hashicorp.services\"\n+\tHashicorpDockerProxy = \"docker.mirror.hashicorp.services\"\n )",
  "test/integration/consul-container/libs/service/examples.go": "@@ -187,7 +187,7 @@ func NewExampleService(ctx context.Context, name string, httpPort int, grpcPort\n \tcommand = append(command, containerArgs...)\n \n \treq := testcontainers.ContainerRequest{\n-\t\tImage:      hashicorpDockerProxy + \"/fortio/fortio\",\n+\t\tImage:      HashicorpDockerProxy + \"/fortio/fortio\",\n \t\tWaitingFor: wait.ForLog(\"\").WithStartupTimeout(60 * time.Second),\n \t\tAutoRemove: false,\n \t\tName:       containerName,",
  "test/integration/consul-container/test/gateways/gateway_endpoint_test.go": "@@ -227,6 +227,7 @@ type checkOptions struct {\n \tresponseHeaders map[string]string\n \tstatusCode      int\n \ttestName        string\n+\texpectedBody    string\n }\n \n // checkRoute, customized version of libassert.RouteEchos to allow for headers/distinguishing between the server instances\n@@ -289,8 +290,13 @@ func checkRoute(t *testing.T, port int, path string, headers map[string]string,\n \t\t\t\treturn false\n \t\t\t}\n \t\t}\n-\t\tif !strings.Contains(string(body), \"hello\") {\n-\t\t\tt.Log(\"body does not contain 'hello'\")\n+\t\texpectedBody := expected.expectedBody\n+\t\tif expectedBody == \"\" {\n+\t\t\texpectedBody = \"hello\"\n+\t\t}\n+\t\tif !strings.Contains(string(body), expectedBody) {\n+\t\t\tt.Log(string(body))\n+\t\t\tt.Log(\"body does not contain \" + expectedBody)\n \t\t\treturn false\n \t\t}\n ",
  "test/integration/consul-container/test/gateways/http_route_test.go": "@@ -8,6 +8,8 @@ import (\n \t\"crypto/rand\"\n \t\"encoding/hex\"\n \t\"fmt\"\n+\t\"github.com/testcontainers/testcontainers-go\"\n+\t\"k8s.io/utils/pointer\"\n \t\"testing\"\n \t\"time\"\n \n@@ -737,3 +739,233 @@ func TestHTTPRouteParentRefChange(t *testing.T) {\n \t\t\"Host\": \"test.foo\",\n \t}, \"\")\n }\n+\n+func TestHTTPRouteRetryAndTimeout(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"too slow for testing.Short\")\n+\t}\n+\n+\tt.Parallel()\n+\n+\t// infrastructure set up\n+\tlistenerPort := 6018\n+\tretryServiceHTTPPort := 6019\n+\tretryServiceGRPCPort := 6020\n+\ttimeoutServiceHTTPPort := 6021\n+\ttimeoutServiceGRPCPort := 6022\n+\n+\tretryServiceName := randomName(\"service\", 16)\n+\tgatewayName := randomName(\"gw\", 16)\n+\tretryRouteName := randomName(\"route\", 16)\n+\ttimeoutServiceName := randomName(\"service\", 16)\n+\ttimeoutRouteName := randomName(\"route\", 16)\n+\tretryPath := \"/retry\"\n+\ttimeoutPath := \"/timeout\"\n+\n+\tclusterConfig := &libtopology.ClusterConfig{\n+\t\tNumServers: 1,\n+\t\tNumClients: 1,\n+\t\tBuildOpts: &libcluster.BuildOptions{\n+\t\t\tDatacenter:             \"dc1\",\n+\t\t\tInjectAutoEncryption:   true,\n+\t\t\tInjectGossipEncryption: true,\n+\t\t\tAllowHTTPAnyway:        true,\n+\t\t},\n+\t\tExposedPorts: []int{\n+\t\t\tlistenerPort,\n+\t\t\tretryServiceGRPCPort,\n+\t\t\tretryServiceHTTPPort,\n+\t\t\ttimeoutServiceGRPCPort,\n+\t\t\ttimeoutServiceHTTPPort,\n+\t\t},\n+\t\tApplyDefaultProxySettings: true,\n+\t}\n+\n+\tcluster, _, _ := libtopology.NewCluster(t, clusterConfig)\n+\tclient := cluster.Agents[0].GetClient()\n+\n+\tnamespace := getOrCreateNamespace(t, client)\n+\n+\t_, _, err := libservice.CreateAndRegisterCustomServiceAndSidecar(\n+\t\tcluster.Agents[0], &libservice.ServiceOpts{\n+\t\t\tID:        retryServiceName,\n+\t\t\tName:      retryServiceName,\n+\t\t\tNamespace: namespace,\n+\t\t\tHTTPPort:  retryServiceHTTPPort,\n+\t\t\tGRPCPort:  retryServiceGRPCPort,\n+\t\t},\n+\t\ttestcontainers.ContainerRequest{\n+\t\t\tImage: libservice.HashicorpDockerProxy + \"/nicholasjackson/fake-service:v0.26.0\",\n+\t\t\tEnv: map[string]string{\n+\t\t\t\t\"LISTEN_ADDR\": fmt.Sprintf(\"0.0.0.0:%d\", retryServiceHTTPPort),\n+\t\t\t\t\"ERROR_RATE\":  \"0.5\",\n+\t\t\t},\n+\t\t},\n+\t\tnil,\n+\t)\n+\trequire.NoError(t, err)\n+\n+\t_, _, err = libservice.CreateAndRegisterCustomServiceAndSidecar(\n+\t\tcluster.Agents[0], &libservice.ServiceOpts{\n+\t\t\tID:        timeoutServiceName,\n+\t\t\tName:      timeoutServiceName,\n+\t\t\tNamespace: namespace,\n+\t\t\tHTTPPort:  timeoutServiceHTTPPort,\n+\t\t\tGRPCPort:  timeoutServiceGRPCPort,\n+\t\t},\n+\t\ttestcontainers.ContainerRequest{\n+\t\t\tImage: libservice.HashicorpDockerProxy + \"/nicholasjackson/fake-service:v0.26.0\",\n+\t\t\tEnv: map[string]string{\n+\t\t\t\t\"LISTEN_ADDR\": fmt.Sprintf(\"0.0.0.0:%d\", timeoutServiceHTTPPort),\n+\t\t\t\t\"ERROR_RATE\":  \"1.0\",\n+\t\t\t\t\"ERROR_DELAY\": \"1m\",\n+\t\t\t},\n+\t\t},\n+\t\tnil,\n+\t)\n+\n+\trequire.NoError(t, err)\n+\n+\t// write config entries\n+\tproxyDefaults := &api.ProxyConfigEntry{\n+\t\tKind: api.ProxyDefaults,\n+\t\tName: api.ProxyConfigGlobal,\n+\t\tConfig: map[string]interface{}{\n+\t\t\t\"protocol\": \"http\",\n+\t\t},\n+\t}\n+\n+\trequire.NoError(t, cluster.ConfigEntryWrite(proxyDefaults))\n+\n+\tapiGateway := &api.APIGatewayConfigEntry{\n+\t\tKind: \"api-gateway\",\n+\t\tName: gatewayName,\n+\t\tListeners: []api.APIGatewayListener{\n+\t\t\t{\n+\t\t\t\tName:     \"listener\",\n+\t\t\t\tPort:     listenerPort,\n+\t\t\t\tProtocol: \"http\",\n+\t\t\t},\n+\t\t},\n+\t\tNamespace: namespace,\n+\t}\n+\n+\tretryRoute := &api.HTTPRouteConfigEntry{\n+\t\tKind:      api.HTTPRoute,\n+\t\tName:      retryRouteName,\n+\t\tNamespace: namespace,\n+\t\tParents: []api.ResourceReference{\n+\t\t\t{\n+\t\t\t\tKind:      api.APIGateway,\n+\t\t\t\tName:      gatewayName,\n+\t\t\t\tNamespace: namespace,\n+\t\t\t},\n+\t\t},\n+\t\tHostnames: []string{\n+\t\t\t\"test.foo\",\n+\t\t\t\"test.example\",\n+\t\t},\n+\t\tRules: []api.HTTPRouteRule{\n+\t\t\t{\n+\t\t\t\tFilters: api.HTTPFilters{\n+\t\t\t\t\tRetryFilter: &api.RetryFilter{\n+\t\t\t\t\t\tNumRetries:         pointer.Uint32(10),\n+\t\t\t\t\t\tRetryOnStatusCodes: []uint32{500},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tServices: []api.HTTPService{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:      retryServiceName,\n+\t\t\t\t\t\tNamespace: namespace,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tMatches: []api.HTTPMatch{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tPath: api.HTTPPathMatch{\n+\t\t\t\t\t\t\tMatch: api.HTTPPathMatchPrefix,\n+\t\t\t\t\t\t\tValue: retryPath,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\ttimeoutRoute := &api.HTTPRouteConfigEntry{\n+\t\tKind:      api.HTTPRoute,\n+\t\tName:      timeoutRouteName,\n+\t\tNamespace: namespace,\n+\t\tParents: []api.ResourceReference{\n+\t\t\t{\n+\t\t\t\tKind:      api.APIGateway,\n+\t\t\t\tName:      gatewayName,\n+\t\t\t\tNamespace: namespace,\n+\t\t\t},\n+\t\t},\n+\t\tHostnames: []string{\n+\t\t\t\"test.foo\",\n+\t\t\t\"test.example\",\n+\t\t},\n+\t\tRules: []api.HTTPRouteRule{\n+\t\t\t{\n+\t\t\t\tFilters: api.HTTPFilters{\n+\t\t\t\t\tTimeoutFilter: &api.TimeoutFilter{\n+\t\t\t\t\t\tRequestTimeout: 1,\n+\t\t\t\t\t\tIdleTimeout:    1,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tServices: []api.HTTPService{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:      timeoutServiceName,\n+\t\t\t\t\t\tNamespace: namespace,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\tMatches: []api.HTTPMatch{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tPath: api.HTTPPathMatch{\n+\t\t\t\t\t\t\tMatch: api.HTTPPathMatchPrefix,\n+\t\t\t\t\t\t\tValue: timeoutPath,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\trequire.NoError(t, cluster.ConfigEntryWrite(apiGateway))\n+\trequire.NoError(t, cluster.ConfigEntryWrite(timeoutRoute))\n+\trequire.NoError(t, cluster.ConfigEntryWrite(retryRoute))\n+\n+\t// create gateway service\n+\tgwCfg := libservice.GatewayConfig{\n+\t\tName:      gatewayName,\n+\t\tKind:      \"api\",\n+\t\tNamespace: namespace,\n+\t}\n+\tgatewayService, err := libservice.NewGatewayService(context.Background(), gwCfg, cluster.Agents[0], listenerPort)\n+\trequire.NoError(t, err)\n+\tlibassert.CatalogServiceExists(t, client, gatewayName, &api.QueryOptions{Namespace: namespace})\n+\n+\t// make sure config entries have been properly created\n+\tcheckGatewayConfigEntry(t, client, gatewayName, &api.QueryOptions{Namespace: namespace})\n+\tt.Log(\"checking retry route\")\n+\tcheckHTTPRouteConfigEntry(t, client, retryRouteName, &api.QueryOptions{Namespace: namespace})\n+\n+\tt.Log(\"checking timeout route\")\n+\tcheckHTTPRouteConfigEntry(t, client, timeoutRouteName, &api.QueryOptions{Namespace: namespace})\n+\n+\t// gateway resolves routes\n+\tgatewayPort, err := gatewayService.GetPort(listenerPort)\n+\trequire.NoError(t, err)\n+\tfmt.Println(\"Gateway Port: \", gatewayPort)\n+\n+\t// hit service 1 by hitting root path\n+\tcheckRoute(t, gatewayPort, retryPath, map[string]string{\n+\t\t\"Host\": \"test.foo\",\n+\t}, checkOptions{debug: false, statusCode: 200, testName: \"retry should succeed cleanly\", expectedBody: \"Hello World\"})\n+\n+\tcheckRoute(t, gatewayPort, timeoutPath, map[string]string{\n+\t\t\"Host\": \"test.foo\",\n+\t}, checkOptions{debug: false, statusCode: 500, testName: \"timeout should timeout\", expectedBody: \"timeout\"})\n+\n+}"
}