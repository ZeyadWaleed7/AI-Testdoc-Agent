{
  ".github/workflows/reusable-lint.yml": "@@ -54,7 +54,7 @@ jobs:\n       - name: Set golangci-lint version\n         run: echo \"GOLANGCI_LINT_VERSION=$(make --no-print-directory print-GOLANGCI_LINT_VERSION)\" >> $GITHUB_ENV\n       - name: lint-${{ matrix.directory }}\n-        uses: golangci/golangci-lint-action@82d40c283aeb1f2b6595839195e95c2d6a49081b # v5.0.0\n+        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8.0.0\n         with:\n           working-directory: ${{ matrix.directory }}\n           version: ${{ env.GOLANGCI_LINT_VERSION }}",
  ".golangci.yml": "@@ -1,124 +1,118 @@\n # Copyright (c) HashiCorp, Inc.\n # SPDX-License-Identifier: BUSL-1.1\n \n+version: \"2\"\n+run:\n+  concurrency: 4\n linters:\n-  disable-all: true\n+  default: none\n   enable:\n-    - gofmt\n+    - depguard\n+    - forbidigo\n+    - gomodguard\n     - govet\n-    - unconvert\n-    - staticcheck\n     - ineffassign\n+    - staticcheck\n+    - unconvert\n     - unparam\n-    - forbidigo\n-    - gomodguard\n-    - depguard\n-\n-issues:\n-  # Disable the default exclude list so that all excludes are explicitly\n-  # defined in this file.\n-  exclude-use-default: false\n-\n-  exclude-rules:\n-    # Temp Ignore SA9004: only the first constant in this group has an explicit type\n-    # https://staticcheck.io/docs/checks#SA9004\n-    - linters: [staticcheck]\n-      text: \"SA9004:\"\n-\n-    - linters: [staticcheck]\n-      text: \"SA1006:\"\n-\n-    - linters: [staticcheck]\n-      text: 'SA1019: \"io/ioutil\" has been deprecated since Go 1.16'\n-\n-    # Allow usage of deprecated values.\n-    - linters: [ staticcheck ]\n-      text: 'SA1019:'\n-      path: \"(agent/grpc-external|agent/grpc-internal)\"\n-\n-    # An argument that always receives the same value is often not a problem.\n-    - linters: [unparam]\n-      text: \"always receives\"\n-\n-    - linters: [ unparam ]\n-      text: 'result \\d+ \\(bool\\) is always false'\n-\n-    # Often functions will implement an interface that returns an error without\n-    # needing to return an error. Sometimes the error return value is unnecessary\n-    # but a linter can not tell the difference.\n-    - linters: [unparam]\n-      text: 'result \\d+ \\(error\\) is always nil'\n-\n-    # Allow unused parameters to start with an underscore. Arguments with a name\n-    # of '_' are already ignored.\n-    # Ignoring longer names that start with underscore allow for better\n-    # self-documentation than a single underscore by itself.  Underscore arguments\n-    # should generally only be used when a function is implementing an interface.\n-    - linters: [unparam]\n-      text: \"`_[^`]*` is unused\"\n-\n-    # Temp ignore some common unused parameters so that unparam can be added\n-    # incrementally.\n-    - linters: [unparam]\n-      text: \"`(t|resp|req|entMeta)` is unused\"\n-\n-    # Temp ignore everything in _ce(_test).go and _ent(_test).go. Many of these\n-    # could use underscore to ignore the unused arguments, but the \"always returns\"\n-    # issue will likely remain in CE, and will need to be excluded.\n-    - linters: [unparam]\n-      path: \"(_ce.go|_ce_test.go|_ent.go|_ent_test.go)\"\n-\n-    - linters: [ staticcheck ]\n-      text: 'SA1019:'\n-\n-linters-settings:\n-  govet:\n-    enable-all: true\n-    disable:\n-      - fieldalignment\n-      - nilness\n-      - shadow\n-      - unusedwrite\n-      - printf\n-  gofmt:\n-    simplify: true\n-  forbidigo:\n-    # Forbid the following identifiers (list of regexp).\n-    # Format includes custom message based on https://github.com/ashanbrown/forbidigo/pull/11\n-    forbid:\n-      - '\\bhtml\\/template\\b(# Use text/template instead)?'\n-      - '\\bioutil\\b(# Use io and os packages instead of ioutil)?'\n-      - '\\brequire\\.New\\b(# Use package-level functions with explicit TestingT)?'\n-      - '\\bassert\\.New\\b(# Use package-level functions with explicit TestingT)?'\n-    # Exclude godoc examples from forbidigo checks.\n-    # Default: true\n-    exclude_godoc_examples: false\n-  gomodguard:\n-    blocked:\n-      # List of blocked modules.\n-      modules:\n-        # Blocked module.\n-        - github.com/hashicorp/net-rpc-msgpackrpc:\n-            recommendations:\n-              - github.com/hashicorp/consul-net-rpc/net-rpc-msgpackrpc\n-        - github.com/hashicorp/go-msgpack:\n-            recommendations:\n-              - github.com/hashicorp/consul-net-rpc/go-msgpack\n-        - github.com/golang/protobuf:\n-            recommendations:\n-              - google.golang.org/protobuf\n-\n-  depguard:\n+  settings:\n+    depguard:\n+      rules:\n+        main:\n+          deny:\n+            - pkg: net/rpc\n+              desc: only use forked copy in github.com/hashicorp/consul-net-rpc/net/rpc\n+            - pkg: github.com/golang/protobuf\n+              desc: only use google.golang.org/protobuf\n+    forbidigo:\n+      forbid:\n+        - pattern: \\bhtml\\/template\\b(# Use text/template instead)?\n+        - pattern: \\bioutil\\b(# Use io and os packages instead of ioutil)?\n+        - pattern: \\brequire\\.New\\b(# Use package-level functions with explicit TestingT)?\n+        - pattern: \\bassert\\.New\\b(# Use package-level functions with explicit TestingT)?\n+    gomodguard:\n+      blocked:\n+        modules:\n+          - github.com/hashicorp/net-rpc-msgpackrpc:\n+              recommendations:\n+                - github.com/hashicorp/consul-net-rpc/net-rpc-msgpackrpc\n+          - github.com/hashicorp/go-msgpack:\n+              recommendations:\n+                - github.com/hashicorp/consul-net-rpc/go-msgpack\n+          - github.com/golang/protobuf:\n+              recommendations:\n+                - google.golang.org/protobuf\n+    govet:\n+      disable:\n+        - fieldalignment\n+        - nilness\n+        - shadow\n+        - unusedwrite\n+        - printf\n+      enable-all: true\n+  exclusions:\n+    generated: lax\n     rules:\n-      main:\n-        listMode: lax\n-        deny:\n-        - pkg: net/rpc\n-          desc: \"only use forked copy in github.com/hashicorp/consul-net-rpc/net/rpc\"\n-        - pkg: github.com/golang/protobuf\n-          desc: \"only use google.golang.org/protobuf\"\n-\n-run:\n-  timeout: 10m\n-  concurrency: 4\n-  skip-dirs-use-default: false\n+      - linters:\n+          - staticcheck\n+        text: 'SA9004:'\n+      - linters:\n+          - staticcheck\n+        text: 'SA1006:'\n+      - linters:\n+          - staticcheck\n+        text: 'SA1019: \"io/ioutil\" has been deprecated since Go 1.16'\n+      - linters:\n+          - staticcheck\n+        path: (agent/grpc-external|agent/grpc-internal)\n+        text: 'SA1019:'\n+      - linters:\n+          - unparam\n+        text: always receives\n+      - linters:\n+          - unparam\n+        text: result \\d+ \\(bool\\) is always false\n+      - linters:\n+          - unparam\n+        text: result \\d+ \\(error\\) is always nil\n+      - linters:\n+          - unparam\n+        text: '`_[^`]*` is unused'\n+      - linters:\n+          - unparam\n+        text: '`(t|resp|req|entMeta)` is unused'\n+      - linters:\n+          - unparam\n+        path: (_ce.go|_ce_test.go|_ent.go|_ent_test.go)\n+      - linters:\n+          - staticcheck\n+        text: 'SA1019:'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1005: error strings should not end with punctuation or newlines'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1012: error var injectedError should have name of the form errFo'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1005: error strings should not be capitalized'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1012: error var'\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n+      - agent/consul\n+formatters:\n+  enable:\n+    - gofmt\n+  settings:\n+    gofmt:\n+      simplify: true\n+  exclusions:\n+    generated: lax\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n\\ No newline at end of file",
  "Makefile": "@@ -10,7 +10,7 @@ GO_MODULES := $(shell find . -name go.mod -exec dirname {} \\; | grep -v \"proto-g\n # These version variables can either be a valid string for \"go install <module>@<version>\"\n # or the string @DEV to imply use what is currently installed locally.\n ###\n-GOLANGCI_LINT_VERSION='v1.64.8'\n+GOLANGCI_LINT_VERSION='v2.4.0'\n MOCKERY_VERSION='v3.5.2'\n BUF_VERSION='v1.26.0'\n ",
  "acl/acl_ce.go": "@@ -32,6 +32,4 @@ type EnterpriseConfig struct {\n \t// no fields in CE\n }\n \n-func (_ *EnterpriseConfig) Close() {\n-\t// do nothing\n-}\n+func (*EnterpriseConfig) Close() {}",
  "acl/enterprisemeta_ce.go": "@@ -117,7 +117,7 @@ func NewEnterpriseMetaWithPartition(_, _ string) EnterpriseMeta {\n }\n \n // FillAuthzContext stub\n-func (_ *EnterpriseMeta) FillAuthzContext(_ *AuthorizerContext) {}\n+func (*EnterpriseMeta) FillAuthzContext(_ *AuthorizerContext) {}\n \n func NormalizeNamespace(_ string) string {\n \treturn \"\"",
  "agent/acl_endpoint.go": "@@ -26,10 +26,7 @@ var aclDisabled = HTTPError{StatusCode: http.StatusUnauthorized, Reason: \"ACL su\n // checkACLDisabled will return a standard response if ACLs are disabled. This\n // returns true if they are disabled and we should not continue.\n func (s *HTTPHandlers) checkACLDisabled() bool {\n-\tif s.agent.config.ACLsEnabled {\n-\t\treturn false\n-\t}\n-\treturn true\n+\treturn !(s.agent.config.ACLsEnabled)\n }\n \n // ACLBootstrap is used to perform a one-time ACL bootstrap operation on",
  "agent/acl_endpoint_test.go": "@@ -34,10 +34,7 @@ import (\n \n func isHTTPBadRequest(err error) bool {\n \tif err, ok := err.(HTTPError); ok {\n-\t\tif err.StatusCode != 400 {\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n+\t\treturn err.StatusCode == http.StatusBadRequest\n \t}\n \treturn false\n }",
  "agent/agent.go": "@@ -4216,10 +4216,8 @@ func revertStaticConfig(oldCfg tlsutil.ProtocolConfig, newCfg tlsutil.ProtocolCo\n \tnewOldcfg := newCfg\n \tnewOldcfg.CertFile = oldCfg.CertFile\n \tnewOldcfg.KeyFile = oldCfg.KeyFile\n-\tif !reflect.DeepEqual(newOldcfg, oldCfg) {\n-\t\treturn true\n-\t}\n-\treturn false\n+\n+\treturn !reflect.DeepEqual(newOldcfg, oldCfg)\n }\n \n // reloadConfigInternal is mainly needed for some unit tests. Instead of parsing",
  "agent/checks/check_test.go": "@@ -1198,11 +1198,10 @@ func mockUDPServer(ctx context.Context, network string, port int) {\n \t\t}\n \t}()\n \n-\tselect {\n-\tcase <-ctx.Done():\n-\t\tfmt.Println(\"cancelled\")\n-\t\tclose(chClose)\n-\t}\n+\t<-ctx.Done()\n+\tfmt.Println(\"cancelled\")\n+\tclose(chClose)\n+\n \twg.Wait()\n }\n \n@@ -1366,7 +1365,7 @@ func TestCheckH2PING(t *testing.T) {\n }\n \n func TestCheckH2PING_TLS_BadVerify(t *testing.T) {\n-\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { return })\n+\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n \tserver := httptest.NewUnstartedServer(handler)\n \tserver.EnableHTTP2 = true\n \tserver.StartTLS()\n@@ -1468,7 +1467,7 @@ func TestCheckH2CPING(t *testing.T) {\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.desc, func(t *testing.T) {\n-\t\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { return })\n+\t\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n \t\t\th2chandler := h2c.NewHandler(handler, &http2.Server{})\n \t\t\tserver := httptest.NewUnstartedServer(h2chandler)\n \t\t\tserver.Config.ReadTimeout = tt.connTimeout",
  "agent/config/config_ce.go": "@@ -13,6 +13,6 @@ import (\n // EnterpriseMeta stub\n type EnterpriseMeta struct{}\n \n-func (_ *EnterpriseMeta) ToStructs() acl.EnterpriseMeta {\n+func (*EnterpriseMeta) ToStructs() acl.EnterpriseMeta {\n \treturn *structs.DefaultEnterpriseMetaInDefaultPartition()\n }",
  "agent/connect/ca/provider_aws_test.go": "@@ -112,7 +112,7 @@ func TestAWSBootstrapAndSignSecondary(t *testing.T) {\n \trootPEM, err := p1.GenerateCAChain()\n \trequire.NoError(t, err)\n \n-\tp2 := testAWSProvider(t, testProviderConfigSecondary(t, nil))\n+\tp2 := testAWSProvider(t, testProviderConfigSecondary(nil))\n \tdefer p2.Cleanup(true, nil)\n \n \ttestSignIntermediateCrossDC(t, p1, p2)\n@@ -202,7 +202,7 @@ func TestAWSBootstrapAndSignSecondary(t *testing.T) {\n \t\tnewIntPEM := strings.TrimSuffix(intPEM, \"\\n\")\n \t\tnewRootPEM := strings.TrimSuffix(rootPEM, \"\\n\")\n \n-\t\tcfg2 := testProviderConfigSecondary(t, map[string]interface{}{\n+\t\tcfg2 := testProviderConfigSecondary(map[string]interface{}{\n \t\t\t\"ExistingARN\": p2State[AWSStateCAARNKey],\n \t\t})\n \t\tp2 = testAWSProvider(t, cfg2)\n@@ -232,7 +232,7 @@ func TestAWSBootstrapAndSignSecondaryConsul(t *testing.T) {\n \t\t_, err := p1.GenerateCAChain()\n \t\trequire.NoError(t, err)\n \n-\t\tp2 := testAWSProvider(t, testProviderConfigSecondary(t, nil))\n+\t\tp2 := testAWSProvider(t, testProviderConfigSecondary(nil))\n \t\tdefer p2.Cleanup(true, nil)\n \n \t\ttestSignIntermediateCrossDC(t, p1, p2)\n@@ -437,7 +437,7 @@ func testProviderConfigPrimary(cfg map[string]interface{}) ProviderConfig {\n \t}\n }\n \n-func testProviderConfigSecondary(t *testing.T, cfg map[string]interface{}) ProviderConfig {\n+func testProviderConfigSecondary(cfg map[string]interface{}) ProviderConfig {\n \tc := testProviderConfigPrimary(cfg)\n \tc.IsPrimary = false\n \tc.Datacenter = \"dc2\"",
  "agent/grpc-external/services/resource/server_ce_test.go": "@@ -7,10 +7,6 @@ package resource_test\n \n import \"github.com/hashicorp/consul/acl\"\n \n-func fillEntMeta(entMeta *acl.EnterpriseMeta) {\n-\treturn\n-}\n+func fillEntMeta(_ *acl.EnterpriseMeta) {}\n \n-func fillAuthorizerContext(authzContext *acl.AuthorizerContext) {\n-\treturn\n-}\n+func fillAuthorizerContext(_ *acl.AuthorizerContext) {}",
  "agent/structs/acl_ce.go": "@@ -54,22 +54,18 @@ type ACLAuthMethodEnterpriseFields struct{}\n \n type ACLAuthMethodEnterpriseMeta struct{}\n \n-func (_ *ACLAuthMethodEnterpriseMeta) FillWithEnterpriseMeta(_ *acl.EnterpriseMeta) {\n+func (*ACLAuthMethodEnterpriseMeta) FillWithEnterpriseMeta(_ *acl.EnterpriseMeta) {\n \t// do nothing\n }\n \n-func (_ *ACLAuthMethodEnterpriseMeta) ToEnterpriseMeta() *acl.EnterpriseMeta {\n+func (*ACLAuthMethodEnterpriseMeta) ToEnterpriseMeta() *acl.EnterpriseMeta {\n \treturn DefaultEnterpriseMetaInDefaultPartition()\n }\n \n func aclServiceIdentityRules(svc string, _ *acl.EnterpriseMeta) string {\n \treturn fmt.Sprintf(aclPolicyTemplateServiceIdentity, svc)\n }\n \n-func aclNodeIdentityRules(node string, _ *acl.EnterpriseMeta) string {\n-\treturn fmt.Sprintf(aclPolicyTemplateNodeIdentity, node)\n-}\n-\n func (p *ACLPolicy) EnterprisePolicyMeta() *acl.EnterprisePolicyMeta {\n \treturn nil\n }",
  "agent/structs/aclfilter/filter.go": "@@ -178,10 +178,8 @@ func (f *Filter) allowGateway(gs *structs.GatewayService) bool {\n \t}\n \n \tgs.Service.FillAuthzContext(&authzContext)\n-\tif !f.allowService(gs.Service.Name, &authzContext) {\n-\t\treturn false\n-\t}\n-\treturn true\n+\n+\treturn f.allowService(gs.Service.Name, &authzContext)\n }\n \n // allowService is used to determine if a service is accessible for an ACL.",
  "agent/structs/config_entry_jwt_provider_test.go": "@@ -20,8 +20,8 @@ func newTestAuthz(t *testing.T, src string) acl.Authorizer {\n \treturn authorizer\n }\n \n-var tenSeconds = 10 * time.Second\n-var hundredSeconds time.Duration = 100 * time.Second\n+var shortInterval = 10 * time.Second\n+var longInterval = 100 * time.Second\n var connectTimeout = time.Duration(5) * time.Second\n \n func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n@@ -215,8 +215,8 @@ func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n \t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n \t\t\t\t\t\tRetryPolicy: &JWKSRetryPolicy{\n \t\t\t\t\t\t\tRetryPolicyBackOff: &RetryPolicyBackOff{\n-\t\t\t\t\t\t\t\tBaseInterval: hundredSeconds,\n-\t\t\t\t\t\t\t\tMaxInterval:  tenSeconds,\n+\t\t\t\t\t\t\t\tBaseInterval: longInterval,\n+\t\t\t\t\t\t\t\tMaxInterval:  shortInterval,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t},\n@@ -318,8 +318,8 @@ func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n \t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n \t\t\t\t\t\tRetryPolicy: &JWKSRetryPolicy{\n \t\t\t\t\t\t\tRetryPolicyBackOff: &RetryPolicyBackOff{\n-\t\t\t\t\t\t\t\tBaseInterval: tenSeconds,\n-\t\t\t\t\t\t\t\tMaxInterval:  hundredSeconds,\n+\t\t\t\t\t\t\t\tBaseInterval: shortInterval,\n+\t\t\t\t\t\t\t\tMaxInterval:  longInterval,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t\tJWKSCluster: &JWKSCluster{\n@@ -359,8 +359,8 @@ func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n \t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n \t\t\t\t\t\tRetryPolicy: &JWKSRetryPolicy{\n \t\t\t\t\t\t\tRetryPolicyBackOff: &RetryPolicyBackOff{\n-\t\t\t\t\t\t\t\tBaseInterval: tenSeconds,\n-\t\t\t\t\t\t\t\tMaxInterval:  hundredSeconds,\n+\t\t\t\t\t\t\t\tBaseInterval: shortInterval,\n+\t\t\t\t\t\t\t\tMaxInterval:  longInterval,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t\tJWKSCluster: &JWKSCluster{",
  "agent/structs/intention_ce.go": "@@ -32,21 +32,21 @@ func (e *IntentionQueryExact) DestinationEnterpriseMeta() *acl.EnterpriseMeta {\n // FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n // extra parameters for ACL enforcement. In CE there is currently nothing\n // extra to be done.\n-func (_ *Intention) FillAuthzContext(_ *acl.AuthorizerContext, _ bool) {\n+func (*Intention) FillAuthzContext(_ *acl.AuthorizerContext, _ bool) {\n \t// do nothing\n }\n \n // FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n // extra parameters for ACL enforcement. In CE there is currently nothing\n // extra to be done.\n-func (_ *IntentionMatchEntry) FillAuthzContext(_ *acl.AuthorizerContext) {\n+func (*IntentionMatchEntry) FillAuthzContext(_ *acl.AuthorizerContext) {\n \t// do nothing\n }\n \n // FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n // extra parameters for ACL enforcement. In CE there is currently nothing\n // extra to be done.\n-func (_ *IntentionQueryCheck) FillAuthzContext(_ *acl.AuthorizerContext) {\n+func (*IntentionQueryCheck) FillAuthzContext(_ *acl.AuthorizerContext) {\n \t// do nothing\n }\n ",
  "agent/structs/structs_ce.go": "@@ -67,30 +67,30 @@ func (n *Node) OverridePartition(_ string) {\n \tn.Partition = \"\"\n }\n \n-func (_ *Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n func (n *NodeInfo) FillAuthzContext(ctx *acl.AuthorizerContext) {\n \tctx.Peer = n.PeerName\n }\n \n // FillAuthzContext stub\n-func (_ *DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n // FillAuthzContext stub\n-func (_ *RegisterRequest) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*RegisterRequest) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n-func (_ *RegisterRequest) GetEnterpriseMeta() *acl.EnterpriseMeta {\n+func (*RegisterRequest) GetEnterpriseMeta() *acl.EnterpriseMeta {\n \treturn nil\n }\n \n // CE Stub\n func (op *TxnNodeOp) FillAuthzContext(ctx *acl.AuthorizerContext) {}\n \n // CE Stub\n-func (_ *TxnServiceOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*TxnServiceOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n // CE Stub\n-func (_ *TxnCheckOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*TxnCheckOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n func NodeNameString(node string, _ *acl.EnterpriseMeta) string {\n \treturn node\n@@ -136,7 +136,7 @@ func (cid CheckID) String() string {\n \treturn string(cid.ID)\n }\n \n-func (_ *HealthCheck) Validate() error {\n+func (*HealthCheck) Validate() error {\n \treturn nil\n }\n ",
  "api/agent_test.go": "@@ -1462,7 +1462,7 @@ func TestAPI_AgentMonitor(t *testing.T) {\n \t\t// Wait for the first log message and validate it\n \t\tselect {\n \t\tcase log := <-logCh:\n-\t\t\tif !(strings.Contains(log, \"[INFO]\") || strings.Contains(log, \"[DEBUG]\")) {\n+\t\t\tif !strings.Contains(log, \"[INFO]\") && !strings.Contains(log, \"[DEBUG]\") {\n \t\t\t\tr.Fatalf(\"bad: %q\", log)\n \t\t\t}\n \t\tcase <-time.After(10 * time.Second):",
  "api/api.go": "@@ -646,9 +646,7 @@ func (c *Client) Headers() http.Header {\n \n \tret := make(http.Header)\n \tfor k, v := range c.headers {\n-\t\tfor _, val := range v {\n-\t\t\tret[k] = append(ret[k], val)\n-\t\t}\n+\t\tret[k] = append(ret[k], v...)\n \t}\n \n \treturn ret\n@@ -1312,7 +1310,7 @@ func generateUnexpectedResponseCodeError(resp *http.Response) error {\n \tio.Copy(&buf, resp.Body)\n \tcloseResponseBody(resp)\n \n-\ttrimmed := strings.TrimSpace(string(buf.Bytes()))\n+\ttrimmed := strings.TrimSpace(buf.String())\n \treturn StatusError{Code: resp.StatusCode, Body: trimmed}\n }\n ",
  "api/api_test.go": "@@ -719,8 +719,7 @@ func TestAPI_ClientTLSOptions(t *testing.T) {\n \t\t_, err = client.Agent().Self()\n \t\t// Check for one of the possible cert error messages\n \t\t// See https://cs.opensource.google/go/go/+/62a994837a57a7d0c58bb364b580a389488446c9\n-\t\tif err == nil || !(strings.Contains(err.Error(), \"tls: bad certificate\") ||\n-\t\t\tstrings.Contains(err.Error(), \"tls: certificate required\")) {\n+\t\tif err == nil || (!strings.Contains(err.Error(), \"tls: bad certificate\") && !strings.Contains(err.Error(), \"tls: certificate required\")) {\n \t\t\tt.Fatalf(\"expected tls certificate error, but got '%v'\", err)\n \t\t}\n \t})",
  "api/catalog_test.go": "@@ -321,7 +321,7 @@ func TestAPI_CatalogServiceUnmanagedProxy(t *testing.T) {\n \n \tcatalog := c.Catalog()\n \n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \n \tretry.Run(t, func(r *retry.R) {\n \t\t_, err := catalog.Register(proxyReg, nil)\n@@ -530,7 +530,7 @@ func TestAPI_CatalogService_Filter(t *testing.T) {\n \n }\n \n-func testUpstreams(t *testing.T) []Upstream {\n+func testUpstreams() []Upstream {\n \treturn []Upstream{\n \t\t{\n \t\t\tDestinationName: \"db\",\n@@ -547,29 +547,17 @@ func testUpstreams(t *testing.T) []Upstream {\n \t}\n }\n \n-func testExpectUpstreamsWithDefaults(t *testing.T, upstreams []Upstream) []Upstream {\n-\tups := make([]Upstream, len(upstreams))\n-\tfor i := range upstreams {\n-\t\tups[i] = upstreams[i]\n-\t\t// Fill in default fields we expect to have back explicitly in a response\n-\t\tif ups[i].DestinationType == \"\" {\n-\t\t\tups[i].DestinationType = UpstreamDestTypeService\n-\t\t}\n-\t}\n-\treturn ups\n-}\n-\n // testUnmanagedProxy returns a fully configured external proxy service suitable\n // for checking that all the config fields make it back in a response intact.\n-func testUnmanagedProxy(t *testing.T) *AgentService {\n+func testUnmanagedProxy() *AgentService {\n \treturn &AgentService{\n \t\tKind: ServiceKindConnectProxy,\n \t\tProxy: &AgentServiceConnectProxyConfig{\n \t\t\tDestinationServiceName: \"web\",\n \t\t\tDestinationServiceID:   \"web1\",\n \t\t\tLocalServiceAddress:    \"127.0.0.2\",\n \t\t\tLocalServicePort:       8080,\n-\t\t\tUpstreams:              testUpstreams(t),\n+\t\t\tUpstreams:              testUpstreams(),\n \t\t\tMode:                   ProxyModeTransparent,\n \t\t\tTransparentProxy: &TransparentProxyConfig{\n \t\t\t\tOutboundListenerPort: 808,\n@@ -583,12 +571,12 @@ func testUnmanagedProxy(t *testing.T) *AgentService {\n \n // testUnmanagedProxyRegistration returns a *CatalogRegistration for a fully\n // configured external proxy.\n-func testUnmanagedProxyRegistration(t *testing.T) *CatalogRegistration {\n+func testUnmanagedProxyRegistration() *CatalogRegistration {\n \treturn &CatalogRegistration{\n \t\tDatacenter: \"dc1\",\n \t\tNode:       \"foobar\",\n \t\tAddress:    \"192.168.10.10\",\n-\t\tService:    testUnmanagedProxy(t),\n+\t\tService:    testUnmanagedProxy(),\n \t}\n }\n \n@@ -600,7 +588,7 @@ func TestAPI_CatalogConnect(t *testing.T) {\n \tcatalog := c.Catalog()\n \n \t// Register service and proxy instances to test against.\n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \n \tproxy := proxyReg.Service\n \n@@ -755,7 +743,7 @@ func TestAPI_CatalogNode(t *testing.T) {\n \tname, err := c.Agent().NodeName()\n \trequire.NoError(t, err)\n \n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \tproxyReg.Node = name\n \tproxyReg.SkipNodeUpdate = true\n \n@@ -806,7 +794,7 @@ func TestAPI_CatalogNodeServiceList(t *testing.T) {\n \tname, err := c.Agent().NodeName()\n \trequire.NoError(t, err)\n \n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \tproxyReg.Node = name\n \tproxyReg.SkipNodeUpdate = true\n ",
  "api/mock_api_test.go": "@@ -26,7 +26,7 @@ func setupMockAPI(t *testing.T) (*mockAPI, *Client) {\n \tmapi.ts = httptest.NewServer(&mapi)\n \tt.Cleanup(func() {\n \t\tmapi.ts.Close()\n-\t\tmapi.Mock.AssertExpectations(t)\n+\t\tmapi.AssertExpectations(t)\n \t})\n \n \tcfg := DefaultConfig()",
  "api/namespace.go": "@@ -85,14 +85,10 @@ func (n *NamespaceACLConfig) UnmarshalJSON(data []byte) error {\n \t}\n \n \tif n.PolicyDefaults == nil {\n-\t\tfor _, pd := range aux.PolicyDefaultsSnake {\n-\t\t\tn.PolicyDefaults = append(n.PolicyDefaults, pd)\n-\t\t}\n+\t\tn.PolicyDefaults = append(n.PolicyDefaults, aux.PolicyDefaultsSnake...)\n \t}\n \tif n.RoleDefaults == nil {\n-\t\tfor _, pd := range aux.RoleDefaultsSnake {\n-\t\t\tn.RoleDefaults = append(n.RoleDefaults, pd)\n-\t\t}\n+\t\tn.RoleDefaults = append(n.RoleDefaults, aux.RoleDefaultsSnake...)\n \t}\n \treturn nil\n }",
  "api/peering.go": "@@ -218,7 +218,7 @@ func (p *Peerings) GenerateToken(ctx context.Context, g PeeringGenerateTokenRequ\n \t\treturn nil, nil, fmt.Errorf(\"peer name cannot be empty\")\n \t}\n \n-\treq := p.c.newRequest(\"POST\", fmt.Sprint(\"/v1/peering/token\"))\n+\treq := p.c.newRequest(\"POST\", \"/v1/peering/token\")\n \treq.setWriteOptions(wq)\n \treq.ctx = ctx\n \treq.obj = g\n@@ -244,7 +244,7 @@ func (p *Peerings) GenerateToken(ctx context.Context, g PeeringGenerateTokenRequ\n \n // TODO(peering): verify this is the ultimate signature we want\n func (p *Peerings) Establish(ctx context.Context, i PeeringEstablishRequest, wq *WriteOptions) (*PeeringEstablishResponse, *WriteMeta, error) {\n-\treq := p.c.newRequest(\"POST\", fmt.Sprint(\"/v1/peering/establish\"))\n+\treq := p.c.newRequest(\"POST\", \"/v1/peering/establish\")\n \treq.setWriteOptions(wq)\n \treq.ctx = ctx\n \treq.obj = i",
  "api/raw_test.go": "@@ -4,7 +4,6 @@\n package api\n \n import (\n-\t\"fmt\"\n \t\"strings\"\n \t\"testing\"\n \n@@ -34,7 +33,7 @@ func TestAPI_RawV2ExportedServices(t *testing.T) {\n \n \tdefer s.Stop()\n \n-\tendpoint := strings.ToLower(fmt.Sprintf(\"/api/multicluster/v2/exportedservices/e1\"))\n+\tendpoint := strings.ToLower(\"/api/multicluster/v2/exportedservices/e1\")\n \twResp := &V2WriteResponse{}\n \n \twReq := &V2WriteRequest{",
  "api/watch/watch.go": "@@ -244,18 +244,18 @@ func assignValueBool(params map[string]interface{}, name string, out *bool) erro\n func assignValueStringSlice(params map[string]interface{}, name string, out *[]string) error {\n \tif raw, ok := params[name]; ok {\n \t\tvar tmp []string\n-\t\tswitch raw.(type) {\n+\t\tswitch raw := raw.(type) {\n \t\tcase string:\n-\t\t\ttmp = make([]string, 1, 1)\n-\t\t\ttmp[0] = raw.(string)\n+\t\t\ttmp = make([]string, 1)\n+\t\t\ttmp[0] = raw\n \t\tcase []string:\n-\t\t\tl := len(raw.([]string))\n-\t\t\ttmp = make([]string, l, l)\n-\t\t\tcopy(tmp, raw.([]string))\n+\t\t\tl := len(raw)\n+\t\t\ttmp = make([]string, l)\n+\t\t\tcopy(tmp, raw)\n \t\tcase []interface{}:\n-\t\t\tl := len(raw.([]interface{}))\n-\t\t\ttmp = make([]string, l, l)\n-\t\t\tfor i, v := range raw.([]interface{}) {\n+\t\t\tl := len(raw)\n+\t\t\ttmp = make([]string, l)\n+\t\t\tfor i, v := range raw {\n \t\t\t\tif s, ok := v.(string); ok {\n \t\t\t\t\ttmp[i] = s\n \t\t\t\t} else {",
  "build-support/scripts/devtools.sh": "@@ -164,9 +164,9 @@ function lint_install {\n \n     install_versioned_tool \\\n         'golangci-lint' \\\n-        'github.com/golangci/golangci-lint' \\\n+        'github.com/golangci/golangci-lint/v2' \\\n         \"${golangci_lint_version}\" \\\n-        'github.com/golangci/golangci-lint/cmd/golangci-lint'\n+        'github.com/golangci/golangci-lint/v2/cmd/golangci-lint'\n \n     install_versioned_tool \\\n         'gci' \\",
  "command/snapshot/inspect/formatter.go": "@@ -41,7 +41,7 @@ func NewFormatter(format string) (Formatter, error) {\n \t}\n }\n \n-func (_ *prettyFormatter) Format(info *OutputFormat) (string, error) {\n+func (*prettyFormatter) Format(info *OutputFormat) (string, error) {\n \tvar b bytes.Buffer\n \ttw := tabwriter.NewWriter(&b, 8, 8, 6, ' ', 0)\n \n@@ -85,7 +85,7 @@ func newJSONFormatter() Formatter {\n \treturn &jsonFormatter{}\n }\n \n-func (_ *jsonFormatter) Format(info *OutputFormat) (string, error) {\n+func (*jsonFormatter) Format(info *OutputFormat) (string, error) {\n \tb, err := json.MarshalIndent(info, \"\", \"   \")\n \tif err != nil {\n \t\treturn \"\", fmt.Errorf(\"Failed to marshal original snapshot stats: %v\", err)",
  "envoyextensions/extensioncommon/resources_test.go": "@@ -20,46 +20,46 @@ func TestInsertHTTPFilter(t *testing.T) {\n \t\terrStr          string\n \t}{\n \t\t\"insert first\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertFirst},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert last\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertLast},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n \t\t},\n \t\t\"insert before first match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after first match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert before last match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after last match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n \t\t},\n \t\t\"insert last after last match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterLastMatch, FilterName: \"c\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n \t\t},\n \t}\n \n@@ -95,40 +95,40 @@ func TestInsertFilter(t *testing.T) {\n \t\terrStr          string\n \t}{\n \t\t\"insert first\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertFirst},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert last\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertLast},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n \t\t},\n \t\t\"insert before first match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after first match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert before last match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after last match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n \t\t},\n \t}\n \n@@ -158,15 +158,15 @@ func makeHttpConMgr(t *testing.T, filters []*envoy_http_v3.HttpFilter) *envoy_li\n \treturn filter\n }\n \n-func makeHttpFilters(t *testing.T, names ...string) []*envoy_http_v3.HttpFilter {\n+func makeHttpFilters(names ...string) []*envoy_http_v3.HttpFilter {\n \tvar filters []*envoy_http_v3.HttpFilter\n \tfor _, name := range names {\n \t\tfilters = append(filters, &envoy_http_v3.HttpFilter{Name: name})\n \t}\n \treturn filters\n }\n \n-func makeFilters(t *testing.T, names ...string) []*envoy_listener_v3.Filter {\n+func makeFilters(names ...string) []*envoy_listener_v3.Filter {\n \tvar filters []*envoy_listener_v3.Filter\n \tfor _, name := range names {\n \t\tfilters = append(filters, &envoy_listener_v3.Filter{Name: name})",
  "internal/resource/http/http_test.go": "@@ -56,7 +56,7 @@ func TestResourceHandler_InputValidation(t *testing.T) {\n \t\t\tScope: resource.ScopeNamespace,\n \t\t},\n \t\tclient,\n-\t\tfunc(req *http.Request, token *string) { return },\n+\t\tfunc(req *http.Request, token *string) {},\n \t\thclog.NewNullLogger(),\n \t}\n "
}