{
  "agent/acl_endpoint_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage agent\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-jose/go-jose/v3/jwt\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/agent/consul/authmethod/testauth\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n\t\"github.com/hashicorp/consul/api\"\n\t\"github.com/hashicorp/consul/internal/go-sso/oidcauth/oidcauthtest\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/testrpc\"\n)\n\n// NOTE: The tests contained herein are designed to test the HTTP API\n//       They are not intended to thoroughly test the backing RPC\n//       functionality as that will be done with other tests.\n\nfunc isHTTPBadRequest(err error) bool {\n\tif err, ok := err.(HTTPError); ok {\n\t\treturn err.StatusCode == http.StatusBadRequest\n\t}\n\treturn false\n}\n\nfunc TestACL_Disabled_Response(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\tt.Parallel()\n\ta := NewTestAgent(t, \"\")\n\tdefer a.Shutdown()\n\n\ttype testCase struct {\n\t\tname string\n\t\tfn   func(resp http.ResponseWriter, req *http.Request) (interface{}, error)\n\t}\n\n\ttests := []testCase{\n\t\t{\"ACLBootstrap\", a.srv.ACLBootstrap},\n\t\t{\"ACLReplicationStatus\", a.srv.ACLReplicationStatus},\n\t\t{\"AgentToken\", a.srv.AgentToken}, // See TestAgent_Token\n\t\t{\"ACLPolicyList\", a.srv.ACLPolicyList},\n\t\t{\"ACLPolicyCRUD\", a.srv.ACLPolicyCRUD},\n\t\t{\"ACLPolicyCreate\", a.srv.ACLPolicyCreate},\n\t\t{\"ACLTokenList\", a.srv.ACLTokenList},\n\t\t{\"ACLTokenCreate\", a.srv.ACLTokenCreate},\n\t\t{\"ACLTokenSelf\", a.srv.ACLTokenSelf},\n\t\t{\"ACLTokenCRUD\", a.srv.ACLTokenCRUD},\n\t\t{\"ACLRoleList\", a.srv.ACLRoleList},\n\t\t{\"ACLRoleCreate\", a.srv.ACLRoleCreate},\n\t\t{\"ACLRoleCRUD\", a.srv.ACLRoleCRUD},\n\t\t{\"ACLBindingRuleList\", a.srv.ACLBindingRuleList},\n\t\t{\"ACLBindingRuleCreate\", a.srv.ACLBindingRuleCreate},\n\t\t{\"ACLBindingRuleCRUD\"",
    "language": "go"
  },
  "agent/checks/check_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage checks\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/hashicorp/consul/agent/mock\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n\t\"github.com/hashicorp/consul/api\"\n\t\"github.com/hashicorp/consul/sdk/freeport\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\nfunc uniqueID() string {\n\tid, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn id\n}\n\nfunc TestCheckMonitor_Script(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\ttests := []struct {\n\t\tscript, status string\n\t}{\n\t\t{\"exit 0\", \"passing\"},\n\t\t{\"exit 1\", \"warning\"},\n\t\t{\"exit 2\", \"critical\"},\n\t\t{\"foobarbaz\", \"critical\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.status, func(t *testing.T) {\n\t\t\tnotif := mock.NewNotify()\n\t\t\tlogger := testutil.Logger(t)\n\t\t\tstatusHandler := NewStatusHandler(notif, logger, 0, 0, 0)\n\n\t\t\tcid := structs.NewCheckID(\"foo\", nil)\n\t\t\tcheck := &CheckMonitor{\n\t\t\t\tNotify:        notif,\n\t\t\t\tCheckID:       cid,\n\t\t\t\tScript:        tt.script,\n\t\t\t\tInterval:      25 * time.Millisecond,\n\t\t\t\tOutputMaxSize: DefaultBufSize,\n\t\t\t\tLogger:        logger,\n\t\t\t\tStatusHandler: statusHandler,\n\t\t\t}\n\t\t\tcheck.Start()\n\t\t\tdefer check.Stop()\n\t\t\tretry.Run(t, func(r *retry.R) {\n\t\t\t\tif got, want := notif.Updates(cid), 2; got < want {\n\t\t\t\t\tr.Fatalf(\"got %d updates want at least %d\", got, want)\n\t\t\t\t}\n\t\t\t\tif got, want := notif.State(cid), tt.status; got != want {\n\t\t\t\t\tr.Fatalf(\"got state %q want %q\", got, want)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestCheckMonitor_Args(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\ttests := []struct {\n\t\targs   []string\n\t\tstatus string\n\t}{\n\t\t{[]stri",
    "language": "go"
  },
  "agent/connect/ca/provider_aws_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage ca\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/service/acmpca\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/agent/connect\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n)\n\n// skipIfAWSNotConfigured skips the test unless ENABLE_AWS_PCA_TESTS=true.\n//\n// These tests are not run in CI.  If you are making changes to the AWS provider\n// you probably want to run these tests locally. The tests will run using any\n// credentials available to the AWS SDK. See\n// https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials\n// for a list of options.\nfunc skipIfAWSNotConfigured(t *testing.T) {\n\tenabled := os.Getenv(\"ENABLE_AWS_PCA_TESTS\")\n\tok, err := strconv.ParseBool(enabled)\n\tif err != nil || !ok {\n\t\tt.Skip(\"Skipping because AWS tests are not enabled\")\n\t}\n}\n\nfunc TestAWSBootstrapAndSignPrimary(t *testing.T) {\n\t// Note not parallel since we could easily hit AWS limits of too many CAs if\n\t// all of these tests run at once.\n\tskipIfAWSNotConfigured(t)\n\n\tfor _, tc := range KeyTestCases {\n\t\ttc := tc\n\t\tt.Run(tc.Desc, func(t *testing.T) {\n\t\t\tcfg := map[string]interface{}{\n\t\t\t\t\"PrivateKeyType\": tc.KeyType,\n\t\t\t\t\"PrivateKeyBits\": tc.KeyBits,\n\t\t\t\t\"RootCertTTL\":    \"8761h\",\n\t\t\t}\n\t\t\tprovider := testAWSProvider(t, testProviderConfigPrimary(cfg))\n\t\t\tdefer provider.Cleanup(true, nil)\n\n\t\t\trootPEM, err := provider.GenerateCAChain()\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Ensure they use the right key type\n\t\t\trootCert, err := connect.ParseCert(rootPEM)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyType, keyBits, err := connect.KeyInfoFromCert(rootCert)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.KeyType, keyType)\n\t\t\trequire.Equal(t, tc.KeyBits, keyBits)\n\n\t\t\t// Ensure that the root cert ttl is withing the configured value\n\t\t\t// computation is similar to how we are passing the TTL thru the aws cl",
    "language": "go"
  },
  "agent/grpc-external/services/resource/server_ce_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage resource_test\n\nimport \"github.com/hashicorp/consul/acl\"\n\nfunc fillEntMeta(_ *acl.EnterpriseMeta) {}\n\nfunc fillAuthorizerContext(_ *acl.AuthorizerContext) {}\n",
    "language": "go"
  },
  "agent/structs/config_entry_jwt_provider_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage structs\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc newTestAuthz(t *testing.T, src string) acl.Authorizer {\n\tpolicy, err := acl.NewPolicyFromSource(src, nil, nil)\n\trequire.NoError(t, err)\n\n\tauthorizer, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)\n\trequire.NoError(t, err)\n\treturn authorizer\n}\n\nvar shortInterval = 10 * time.Second\nvar longInterval = 100 * time.Second\nvar connectTimeout = time.Duration(5) * time.Second\n\nfunc TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n\tdefaultMeta := DefaultEnterpriseMetaInDefaultPartition()\n\n\tcases := map[string]configEntryTestcase{\n\t\t\"valid jwt-provider - local jwks\": {\n\t\t\tentry: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tLocal: &LocalJWKS{\n\t\t\t\t\t\tFilename: \"jwks.txt\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tLocal: &LocalJWKS{\n\t\t\t\t\t\tFilename: \"jwks.txt\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tClockSkewSeconds: DefaultClockSkewSeconds,\n\t\t\t\tEnterpriseMeta:   *defaultMeta,\n\t\t\t},\n\t\t},\n\t\t\"valid jwt-provider - remote jwks defaults\": {\n\t\t\tentry: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tRemote: &RemoteJWKS{\n\t\t\t\t\t\tFetchAsynchronously: true,\n\t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tLocations: []*JWTLocation{\n\t\t\t\t\t{\n\t\t\t\t\t\tHeader: &JWTLocationHeader{\n\t\t\t\t\t\t\tName: \"Authorization\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tForwarding: &JWTForwardingConfig{\n\t\t\t\t\tHeaderName: \"Some-Header\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tRemote: &RemoteJWKS{\n\t\t\t\t\t\tFetchAsync",
    "language": "go"
  },
  "api/agent_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/serf/serf\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\nfunc TestAPI_AgentSelf(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tagent := c.Agent()\n\n\tinfo, err := agent.Self()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tname := info[\"Config\"][\"NodeName\"].(string)\n\tif name == \"\" {\n\t\tt.Fatalf(\"bad: %v\", info)\n\t}\n}\n\nfunc TestAPI_AgentMetrics(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tagent := c.Agent()\n\ts.WaitForSerfCheck(t)\n\n\ttimer := &retry.Timer{Timeout: 10 * time.Second, Wait: 500 * time.Millisecond}\n\tretry.RunWith(timer, t, func(r *retry.R) {\n\t\tmetrics, err := agent.Metrics()\n\t\tif err != nil {\n\t\t\tr.Fatalf(\"err: %v\", err)\n\t\t}\n\t\thostname, err := os.Hostname()\n\t\tif err != nil {\n\t\t\tr.Fatalf(\"error determining hostname: %v\", err)\n\t\t}\n\t\tmetricName := fmt.Sprintf(\"consul.%s.runtime.alloc_bytes\", hostname)\n\t\tfor _, g := range metrics.Gauges {\n\t\t\tif g.Name == metricName {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tr.Fatalf(\"missing runtime metrics\")\n\t})\n}\n\nfunc TestAPI_AgentHost(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tagent := c.Agent()\n\ttimer := &retry.Timer{}\n\tretry.RunWith(timer, t, func(r *retry.R) {\n\t\thost, err := agent.Host()\n\t\tif err != nil {\n\t\t\tr.Fatalf(\"err: %v\", err)\n\t\t}\n\n\t\t// CollectionTime should exist on all responses\n\t\tif host[\"CollectionTime\"] == nil {\n\t\t\tr.Fatalf(\"missing host response\")\n\t\t}\n\t})\n}\n\nfunc TestAPI_AgentReload(t *testing.T) {\n\tt.Parallel()\n\n\t// Create our initial empty config file, to be overwritten later\n\tcfgDir := testutil.TempDir(t, \"consul-config\")\n\n\tcfgFilePath := filepath.Join(cfgDir,",
    "language": "go"
  },
  "api/api_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\ntype configCallback func(c *Config)\n\nfunc makeClient(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, nil, nil)\n}\n\nfunc makeClientWithoutConnect(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, nil, func(serverConfig *testutil.TestServerConfig) {\n\t\tserverConfig.Connect = nil\n\t})\n}\n\nfunc makeACLClient(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, func(clientConfig *Config) {\n\t\tclientConfig.Token = \"root\"\n\t}, func(serverConfig *testutil.TestServerConfig) {\n\t\tserverConfig.PrimaryDatacenter = \"dc1\"\n\t\tserverConfig.ACL.Tokens.InitialManagement = \"root\"\n\t\tserverConfig.ACL.Tokens.Agent = \"root\"\n\t\tserverConfig.ACL.Enabled = true\n\t\tserverConfig.ACL.DefaultPolicy = \"deny\"\n\t})\n}\n\n// Makes a client with Audit enabled, it requires ACLs\nfunc makeAuditClient(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, func(clientConfig *Config) {\n\t\tclientConfig.Token = \"root\"\n\t}, func(serverConfig *testutil.TestServerConfig) {\n\t\tserverConfig.PrimaryDatacenter = \"dc1\"\n\t\tserverConfig.ACL.Tokens.InitialManagement = \"root\"\n\t\tserverConfig.ACL.Tokens.Agent = \"root\"\n\t\tserverConfig.ACL.Enabled = true\n\t\tserverConfig.ACL.DefaultPolicy = \"deny\"\n\t\tserverConfig.Audit = &testutil.TestAuditConfig{\n\t\t\tEnabled: true,\n\t\t}\n\t})\n}\n\nfunc makeNonBootstrappedACLClient(t *testing.T, defaultPolicy string) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t,\n\t\tfunc(clientConfig *Con",
    "language": "go"
  },
  "api/catalog_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\nfunc TestAPI_CatalogDatacenters(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tcatalog := c.Catalog()\n\tretry.Run(t, func(r *retry.R) {\n\t\tdatacenters, err := catalog.Datacenters()\n\t\tif err != nil {\n\t\t\tr.Fatal(err)\n\t\t}\n\t\tif len(datacenters) < 1 {\n\t\t\tr.Fatal(\"got 0 datacenters want at least one\")\n\t\t}\n\t})\n}\n\nfunc TestAPI_CatalogNodes(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\ts.WaitForSerfCheck(t)\n\tcatalog := c.Catalog()\n\n\tretry.Run(t, func(r *retry.R) {\n\t\tnodes, meta, err := catalog.Nodes(nil)\n\t\trequire.NoError(r, err)\n\t\trequire.Len(r, nodes, 1)\n\t\trequire.True(r, meta.LastIndex >= 1, \"Last index must be greater than 1\")\n\n\t\t// The raft indexes are not relevant for this test.\n\t\tgot := nodes[0]\n\t\tgot.CreateIndex = 0\n\t\tgot.ModifyIndex = 0\n\n\t\twant := &Node{\n\t\t\tID:         s.Config.NodeID,\n\t\t\tNode:       s.Config.NodeName,\n\t\t\tPartition:  defaultPartition,\n\t\t\tAddress:    \"127.0.0.1\",\n\t\t\tDatacenter: \"dc1\",\n\t\t\tTaggedAddresses: map[string]string{\n\t\t\t\t\"lan\":      \"127.0.0.1\",\n\t\t\t\t\"lan_ipv4\": \"127.0.0.1\",\n\t\t\t\t\"wan\":      \"127.0.0.1\",\n\t\t\t\t\"wan_ipv4\": \"127.0.0.1\",\n\t\t\t},\n\t\t\tMeta: map[string]string{\n\t\t\t\t\"consul-network-segment\": \"\",\n\t\t\t\t\"consul-version\":         s.Config.Version,\n\t\t\t},\n\t\t}\n\t\trequire.Equal(r, want, got)\n\t})\n}\n\nfunc TestAPI_CatalogNodes_MetaFilter(t *testing.T) {\n\tt.Parallel()\n\tmeta := map[string]string{\"somekey\": \"somevalue\"}\n\tc, s := makeClientWithConfig(t, nil, func(conf *testutil.TestServerConfig) {\n\t\tconf.NodeMeta = meta\n\t})\n\tdefer s.Stop()\n\n\tcatalog := c.Catalog()\n\t// Make sure we get the node back when filtering by its metadata\n\tretry.Run(t, func(r *retry.R) {\n\t\tnodes, meta, err := catalog.Nodes(&QueryOptions{NodeMeta: ",
    "language": "go"
  },
  "api/mock_api_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype mockAPI struct {\n\tts *httptest.Server\n\tt  *testing.T\n\tmock.Mock\n}\n\nfunc setupMockAPI(t *testing.T) (*mockAPI, *Client) {\n\tmapi := mockAPI{t: t}\n\tmapi.Test(t)\n\tmapi.ts = httptest.NewServer(&mapi)\n\tt.Cleanup(func() {\n\t\tmapi.ts.Close()\n\t\tmapi.AssertExpectations(t)\n\t})\n\n\tcfg := DefaultConfig()\n\tcfg.Address = mapi.ts.URL\n\n\tclient, err := NewClient(cfg)\n\trequire.NoError(t, err)\n\treturn &mapi, client\n}\n\nfunc (m *mockAPI) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar body interface{}\n\n\tif r.Body != nil {\n\t\tbodyBytes, err := io.ReadAll(r.Body)\n\t\tif err == nil && len(bodyBytes) > 0 {\n\t\t\tbody = bodyBytes\n\n\t\t\tvar bodyMap map[string]interface{}\n\t\t\tif err := json.Unmarshal(bodyBytes, &bodyMap); err != nil {\n\t\t\t\tbody = bodyMap\n\t\t\t}\n\t\t}\n\t}\n\n\tret := m.Called(r.Method, r.URL.Path, body)\n\n\tif replyFn, ok := ret.Get(0).(func(http.ResponseWriter, *http.Request)); ok {\n\t\treplyFn(w, r)\n\t\treturn\n\t}\n}\n\nfunc (m *mockAPI) static(method string, path string, body interface{}) *mock.Call {\n\treturn m.On(\"ServeHTTP\", method, path, body)\n}\n\nfunc (m *mockAPI) withReply(method, path string, body interface{}, status int, reply interface{}) *mock.Call {\n\treturn m.static(method, path, body).Return(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(status)\n\n\t\tif reply == nil {\n\t\t\treturn\n\t\t}\n\n\t\trdr, ok := reply.(io.Reader)\n\t\tif ok {\n\t\t\tio.Copy(w, rdr)\n\t\t\treturn\n\t\t}\n\n\t\tenc := json.NewEncoder(w)\n\t\trequire.NoError(m.t, enc.Encode(reply))\n\t})\n}\n",
    "language": "go"
  },
  "api/raw_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n)\n\ntype V2WriteRequest struct {\n\tData map[string]any `json:\"data\"`\n}\n\ntype V2WriteResponse struct {\n\tID struct {\n\t\tName string `json:\"name\"`\n\t} `json:\"id\"`\n\tData map[string]any `json:\"data\"`\n}\n\n// We are testing a v2 endpoint here in the v1 api module as a temporary measure to\n// support v2 CRUD operations, until we have a final design for v2 api clients.\nfunc TestAPI_RawV2ExportedServices(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClientWithConfig(t, nil, func(conf *testutil.TestServerConfig) {\n\t\tconf.EnableDebug = true\n\t})\n\n\tdefer s.Stop()\n\n\tendpoint := strings.ToLower(\"/api/multicluster/v2/exportedservices/e1\")\n\twResp := &V2WriteResponse{}\n\n\twReq := &V2WriteRequest{\n\t\tData: map[string]any{\n\t\t\t\"consumers\": []map[string]any{\n\t\t\t\t{\"peer\": \"p1\"},\n\t\t\t},\n\t\t\t\"services\": []string{\"s1\"},\n\t\t},\n\t}\n\n\t_, err := c.Raw().Write(endpoint, wReq, wResp, &WriteOptions{Datacenter: \"dc1\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, wResp.ID.Name)\n\n\tqOpts := &QueryOptions{Datacenter: \"dc1\"}\n\n\tvar out map[string]interface{}\n\t_, err = c.Raw().Query(endpoint, &out, qOpts)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, map[string]any{\n\t\t\"consumers\": []any{\n\t\t\tmap[string]any{\"peer\": \"p1\"},\n\t\t},\n\t\t\"services\": []any{\"s1\"},\n\t}, out[\"data\"])\n\n\t_, err = c.Raw().Delete(endpoint, qOpts)\n\trequire.NoError(t, err)\n\n\tout = make(map[string]interface{})\n\t_, err = c.Raw().Query(endpoint, &out, qOpts)\n\trequire.ErrorContains(t, err, \"404\")\n}\n",
    "language": "go"
  },
  "command/snapshot/inspect/formatter.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage inspect\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/tabwriter\"\n)\n\nconst (\n\tPrettyFormat string = \"pretty\"\n\tJSONFormat   string = \"json\"\n)\n\ntype Formatter interface {\n\tFormat(*OutputFormat) (string, error)\n}\n\nfunc GetSupportedFormats() []string {\n\treturn []string{PrettyFormat, JSONFormat}\n}\n\ntype prettyFormatter struct{}\n\nfunc newPrettyFormatter() Formatter {\n\treturn &prettyFormatter{}\n}\nfunc NewFormatter(format string) (Formatter, error) {\n\tswitch format {\n\tcase PrettyFormat:\n\t\treturn newPrettyFormatter(), nil\n\tcase JSONFormat:\n\t\treturn newJSONFormatter(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Unknown format: %s\", format)\n\t}\n}\n\nfunc (*prettyFormatter) Format(info *OutputFormat) (string, error) {\n\tvar b bytes.Buffer\n\ttw := tabwriter.NewWriter(&b, 8, 8, 6, ' ', 0)\n\n\tfmt.Fprintf(tw, \" ID\\t%s\", info.Meta.ID)\n\tfmt.Fprintf(tw, \"\\n Size\\t%d\", info.Meta.Size)\n\tfmt.Fprintf(tw, \"\\n Index\\t%d\", info.Meta.Index)\n\tfmt.Fprintf(tw, \"\\n Term\\t%d\", info.Meta.Term)\n\tfmt.Fprintf(tw, \"\\n Version\\t%d\", info.Meta.Version)\n\tfmt.Fprintf(tw, \"\\n\")\n\tfmt.Fprintln(tw, \"\\n Type\\tCount\\tSize\")\n\tfmt.Fprintf(tw, \" %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\t// For each different type generate new output\n\tfor _, s := range info.Stats {\n\t\tfmt.Fprintf(tw, \"\\n %s\\t%d\\t%s\", s.Name, s.Count, ByteSize(uint64(s.Sum)))\n\t}\n\tfmt.Fprintf(tw, \"\\n %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\tfmt.Fprintf(tw, \"\\n Total\\t\\t%s\", ByteSize(uint64(info.TotalSize)))\n\n\tif info.StatsKV != nil {\n\t\tfmt.Fprintf(tw, \"\\n\")\n\t\tfmt.Fprintln(tw, \"\\n Key Name\\tCount\\tSize\")\n\t\tfmt.Fprintf(tw, \" %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\t\t// For each different type generate new output\n\t\tfor _, s := range info.StatsKV {\n\t\t\tfmt.Fprintf(tw, \"\\n %s\\t%d\\t%s\", s.Name, s.Count, ByteSize(uint64(s.Sum)))\n\t\t}\n\t\tfmt.Fprintf(tw, \"\\n %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\t\tfmt.Fprintf(tw, \"\\n Total\\t\\t%s\", ByteSize(uint64(info.TotalSizeKV)))\n\t}\n\n\tif err := ",
    "language": "go"
  },
  "envoyextensions/extensioncommon/resources_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage extensioncommon\n\nimport (\n\t\"testing\"\n\n\tenvoy_listener_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tenvoy_http_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestInsertHTTPFilter(t *testing.T) {\n\tcases := map[string]struct {\n\t\tinputFilters    []*envoy_http_v3.HttpFilter\n\t\tinsertOptions   InsertOptions\n\t\tfilterName      string\n\t\texpectedFilters []*envoy_http_v3.HttpFilter\n\t\terrStr          string\n\t}{\n\t\t\"insert first\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertFirst},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t},\n\t\t\"insert last\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertLast},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n\t\t},\n\t\t\"insert before first match\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeFirstMatch, FilterName: \"b\"},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n\t\t},\n\t\t\"insert after first match\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertAfterFirstMatch, FilterName: \"b\"},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n\t\t},\n\t\t\"insert before last match\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeLastMatch, FilterName: \"b\"},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"test.filter\", \"b\",",
    "language": "go"
  },
  "internal/resource/http/http_test.go": {
    "content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage http\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/go-hclog\"\n\n\tsvc \"github.com/hashicorp/consul/agent/grpc-external/services/resource\"\n\tsvctest \"github.com/hashicorp/consul/agent/grpc-external/services/resource/testing\"\n\t\"github.com/hashicorp/consul/internal/resource\"\n\t\"github.com/hashicorp/consul/internal/resource/demo\"\n\t\"github.com/hashicorp/consul/proto-public/pbresource\"\n\tpbdemov1 \"github.com/hashicorp/consul/proto/private/pbdemo/v1\"\n\tpbdemov2 \"github.com/hashicorp/consul/proto/private/pbdemo/v2\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n)\n\nconst testACLTokenArtistReadPolicy = \"00000000-0000-0000-0000-000000000001\"\nconst testACLTokenArtistWritePolicy = \"00000000-0000-0000-0000-000000000002\"\nconst testACLTokenArtistListPolicy = \"00000000-0000-0000-0000-000000000003\"\nconst fakeToken = \"fake-token\"\n\nfunc parseToken(req *http.Request, token *string) {\n\t*token = req.Header.Get(\"x-consul-token\")\n}\n\nfunc TestResourceHandler_InputValidation(t *testing.T) {\n\ttype testCase struct {\n\t\tdescription          string\n\t\trequest              *http.Request\n\t\tresponse             *httptest.ResponseRecorder\n\t\texpectedResponseCode int\n\t\tresponseBodyContains string\n\t}\n\n\tclient := svctest.NewResourceServiceBuilder().\n\t\tWithRegisterFns(demo.RegisterTypes).\n\t\tRun(t)\n\n\tresourceHandler := resourceHandler{\n\t\tresource.Registration{\n\t\t\tType:  demo.TypeV2Artist,\n\t\t\tProto: &pbdemov2.Artist{},\n\t\t\tScope: resource.ScopeNamespace,\n\t\t},\n\t\tclient,\n\t\tfunc(req *http.Request, token *string) {},\n\t\thclog.NewNullLogger(),\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tdescription: \"missing resource name\",\n\t\t\trequest: httptest.NewRequest(\"PUT\", \"/?partition=default&peer_name=local&namespace=default\", strings.NewReader(`\n\t\t\t\t{\n\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\"foo\": \"bar\"\n\t\t\t\t\t},\n\t\t\t\t\t\"data\": {\n\t\t\t\t\t",
    "language": "go"
  }
}