{
  ".github/workflows/reusable-lint.yml": {
    "status": "modified",
    "patch": "@@ -54,7 +54,7 @@ jobs:\n       - name: Set golangci-lint version\n         run: echo \"GOLANGCI_LINT_VERSION=$(make --no-print-directory print-GOLANGCI_LINT_VERSION)\" >> $GITHUB_ENV\n       - name: lint-${{ matrix.directory }}\n-        uses: golangci/golangci-lint-action@82d40c283aeb1f2b6595839195e95c2d6a49081b # v5.0.0\n+        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8.0.0\n         with:\n           working-directory: ${{ matrix.directory }}\n           version: ${{ env.GOLANGCI_LINT_VERSION }}",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "yml",
    "imports": [],
    "full_content": "name: reusable-lint\n\non:\n  workflow_call:\n    inputs:\n      go-arch:\n        required: false\n        type: string\n        default: \"\"\n      go-version:\n        required: true\n        type: string\n      runs-on:\n        description: An expression indicating which kind of runners to use.\n        required: true\n        type: string\n      repository-name:\n        required: true\n        type: string\n    secrets:\n      elevated-github-token:\n        required: true\nenv:\n  GOTAGS: \"${{ github.event.repository.name == 'consul-enterprise' && 'consulent consuldev' || '' }}\"\n  GOARCH: ${{inputs.go-arch}}\n  GOPRIVATE: github.com/hashicorp # Required for enterprise deps\n\njobs:\n  lint:\n    runs-on: ${{ fromJSON(inputs.runs-on) }}\n    strategy:\n      matrix:\n        directory: \n        - \"\"\n        - \"api\"\n        - \"sdk\"\n        - \"envoyextensions\"\n        - \"troubleshoot\"\n        - \"test/integration/consul-container\"\n        - \"test-integ\"\n        - \"testing/deployer\"\n      fail-fast: true\n    name: lint ${{ matrix.directory }}\n    steps:\n      - uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.1.4\n      # NOTE: This step is specifically needed for ENT. It allows us to access the required private HashiCorp repos.\n      - name: Setup Git\n        if: ${{ endsWith(inputs.repository-name, '-enterprise') }}\n        run: git config --global url.\"https://${{ secrets.elevated-github-token }}:@github.com\".insteadOf \"https://github.com\"\n      - uses: actions/setup-go@0c52d547c9bc32b1aa3301fd7a9cb496313a4491 # v5.0.0\n        with:\n          go-version: ${{ inputs.go-version }}\n      - run: go env\n      - name: Set golangci-lint version\n        run: echo \"GOLANGCI_LINT_VERSION=$(make --no-print-directory print-GOLANGCI_LINT_VERSION)\" >> $GITHUB_ENV\n      - name: lint-${{ matrix.directory }}\n        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8.0.0\n        with:\n          working-directory: ${{ matrix.directory }}\n          version: ${{ ",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/.github%2Fworkflows%2Freusable-lint.yml",
    "is_test_file": false
  },
  ".golangci.yml": {
    "status": "modified",
    "patch": "@@ -1,124 +1,118 @@\n # Copyright (c) HashiCorp, Inc.\n # SPDX-License-Identifier: BUSL-1.1\n \n+version: \"2\"\n+run:\n+  concurrency: 4\n linters:\n-  disable-all: true\n+  default: none\n   enable:\n-    - gofmt\n+    - depguard\n+    - forbidigo\n+    - gomodguard\n     - govet\n-    - unconvert\n-    - staticcheck\n     - ineffassign\n+    - staticcheck\n+    - unconvert\n     - unparam\n-    - forbidigo\n-    - gomodguard\n-    - depguard\n-\n-issues:\n-  # Disable the default exclude list so that all excludes are explicitly\n-  # defined in this file.\n-  exclude-use-default: false\n-\n-  exclude-rules:\n-    # Temp Ignore SA9004: only the first constant in this group has an explicit type\n-    # https://staticcheck.io/docs/checks#SA9004\n-    - linters: [staticcheck]\n-      text: \"SA9004:\"\n-\n-    - linters: [staticcheck]\n-      text: \"SA1006:\"\n-\n-    - linters: [staticcheck]\n-      text: 'SA1019: \"io/ioutil\" has been deprecated since Go 1.16'\n-\n-    # Allow usage of deprecated values.\n-    - linters: [ staticcheck ]\n-      text: 'SA1019:'\n-      path: \"(agent/grpc-external|agent/grpc-internal)\"\n-\n-    # An argument that always receives the same value is often not a problem.\n-    - linters: [unparam]\n-      text: \"always receives\"\n-\n-    - linters: [ unparam ]\n-      text: 'result \\d+ \\(bool\\) is always false'\n-\n-    # Often functions will implement an interface that returns an error without\n-    # needing to return an error. Sometimes the error return value is unnecessary\n-    # but a linter can not tell the difference.\n-    - linters: [unparam]\n-      text: 'result \\d+ \\(error\\) is always nil'\n-\n-    # Allow unused parameters to start with an underscore. Arguments with a name\n-    # of '_' are already ignored.\n-    # Ignoring longer names that start with underscore allow for better\n-    # self-documentation than a single underscore by itself.  Underscore arguments\n-    # should generally only be used when a function is implementing an interface.\n-    - linters: [unparam]\n-      text: \"`_[^`]*` is unused\"\n-\n-    # Temp ignore some common unused parameters so that unparam can be added\n-    # incrementally.\n-    - linters: [unparam]\n-      text: \"`(t|resp|req|entMeta)` is unused\"\n-\n-    # Temp ignore everything in _ce(_test).go and _ent(_test).go. Many of these\n-    # could use underscore to ignore the unused arguments, but the \"always returns\"\n-    # issue will likely remain in CE, and will need to be excluded.\n-    - linters: [unparam]\n-      path: \"(_ce.go|_ce_test.go|_ent.go|_ent_test.go)\"\n-\n-    - linters: [ staticcheck ]\n-      text: 'SA1019:'\n-\n-linters-settings:\n-  govet:\n-    enable-all: true\n-    disable:\n-      - fieldalignment\n-      - nilness\n-      - shadow\n-      - unusedwrite\n-      - printf\n-  gofmt:\n-    simplify: true\n-  forbidigo:\n-    # Forbid the following identifiers (list of regexp).\n-    # Format includes custom message based on https://github.com/ashanbrown/forbidigo/pull/11\n-    forbid:\n-      - '\\bhtml\\/template\\b(# Use text/template instead)?'\n-      - '\\bioutil\\b(# Use io and os packages instead of ioutil)?'\n-      - '\\brequire\\.New\\b(# Use package-level functions with explicit TestingT)?'\n-      - '\\bassert\\.New\\b(# Use package-level functions with explicit TestingT)?'\n-    # Exclude godoc examples from forbidigo checks.\n-    # Default: true\n-    exclude_godoc_examples: false\n-  gomodguard:\n-    blocked:\n-      # List of blocked modules.\n-      modules:\n-        # Blocked module.\n-        - github.com/hashicorp/net-rpc-msgpackrpc:\n-            recommendations:\n-              - github.com/hashicorp/consul-net-rpc/net-rpc-msgpackrpc\n-        - github.com/hashicorp/go-msgpack:\n-            recommendations:\n-              - github.com/hashicorp/consul-net-rpc/go-msgpack\n-        - github.com/golang/protobuf:\n-            recommendations:\n-              - google.golang.org/protobuf\n-\n-  depguard:\n+  settings:\n+    depguard:\n+      rules:\n+        main:\n+          deny:\n+            - pkg: net/rpc\n+              desc: only use forked copy in github.com/hashicorp/consul-net-rpc/net/rpc\n+            - pkg: github.com/golang/protobuf\n+              desc: only use google.golang.org/protobuf\n+    forbidigo:\n+      forbid:\n+        - pattern: \\bhtml\\/template\\b(# Use text/template instead)?\n+        - pattern: \\bioutil\\b(# Use io and os packages instead of ioutil)?\n+        - pattern: \\brequire\\.New\\b(# Use package-level functions with explicit TestingT)?\n+        - pattern: \\bassert\\.New\\b(# Use package-level functions with explicit TestingT)?\n+    gomodguard:\n+      blocked:\n+        modules:\n+          - github.com/hashicorp/net-rpc-msgpackrpc:\n+              recommendations:\n+                - github.com/hashicorp/consul-net-rpc/net-rpc-msgpackrpc\n+          - github.com/hashicorp/go-msgpack:\n+              recommendations:\n+                - github.com/hashicorp/consul-net-rpc/go-msgpack\n+          - github.com/golang/protobuf:\n+              recommendations:\n+                - google.golang.org/protobuf\n+    govet:\n+      disable:\n+        - fieldalignment\n+        - nilness\n+        - shadow\n+        - unusedwrite\n+        - printf\n+      enable-all: true\n+  exclusions:\n+    generated: lax\n     rules:\n-      main:\n-        listMode: lax\n-        deny:\n-        - pkg: net/rpc\n-          desc: \"only use forked copy in github.com/hashicorp/consul-net-rpc/net/rpc\"\n-        - pkg: github.com/golang/protobuf\n-          desc: \"only use google.golang.org/protobuf\"\n-\n-run:\n-  timeout: 10m\n-  concurrency: 4\n-  skip-dirs-use-default: false\n+      - linters:\n+          - staticcheck\n+        text: 'SA9004:'\n+      - linters:\n+          - staticcheck\n+        text: 'SA1006:'\n+      - linters:\n+          - staticcheck\n+        text: 'SA1019: \"io/ioutil\" has been deprecated since Go 1.16'\n+      - linters:\n+          - staticcheck\n+        path: (agent/grpc-external|agent/grpc-internal)\n+        text: 'SA1019:'\n+      - linters:\n+          - unparam\n+        text: always receives\n+      - linters:\n+          - unparam\n+        text: result \\d+ \\(bool\\) is always false\n+      - linters:\n+          - unparam\n+        text: result \\d+ \\(error\\) is always nil\n+      - linters:\n+          - unparam\n+        text: '`_[^`]*` is unused'\n+      - linters:\n+          - unparam\n+        text: '`(t|resp|req|entMeta)` is unused'\n+      - linters:\n+          - unparam\n+        path: (_ce.go|_ce_test.go|_ent.go|_ent_test.go)\n+      - linters:\n+          - staticcheck\n+        text: 'SA1019:'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1005: error strings should not end with punctuation or newlines'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1012: error var injectedError should have name of the form errFo'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1005: error strings should not be capitalized'\n+      - linters:\n+          - staticcheck\n+        text: 'ST1012: error var'\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n+      - agent/consul\n+formatters:\n+  enable:\n+    - gofmt\n+  settings:\n+    gofmt:\n+      simplify: true\n+  exclusions:\n+    generated: lax\n+    paths:\n+      - third_party$\n+      - builtin$\n+      - examples$\n\\ No newline at end of file",
    "additions": 109,
    "deletions": 115,
    "changes": 224,
    "language": "yml",
    "imports": [],
    "full_content": "# Copyright (c) HashiCorp, Inc.\n# SPDX-License-Identifier: BUSL-1.1\n\nversion: \"2\"\nrun:\n  concurrency: 4\nlinters:\n  default: none\n  enable:\n    - depguard\n    - forbidigo\n    - gomodguard\n    - govet\n    - ineffassign\n    - staticcheck\n    - unconvert\n    - unparam\n  settings:\n    depguard:\n      rules:\n        main:\n          deny:\n            - pkg: net/rpc\n              desc: only use forked copy in github.com/hashicorp/consul-net-rpc/net/rpc\n            - pkg: github.com/golang/protobuf\n              desc: only use google.golang.org/protobuf\n    forbidigo:\n      forbid:\n        - pattern: \\bhtml\\/template\\b(# Use text/template instead)?\n        - pattern: \\bioutil\\b(# Use io and os packages instead of ioutil)?\n        - pattern: \\brequire\\.New\\b(# Use package-level functions with explicit TestingT)?\n        - pattern: \\bassert\\.New\\b(# Use package-level functions with explicit TestingT)?\n    gomodguard:\n      blocked:\n        modules:\n          - github.com/hashicorp/net-rpc-msgpackrpc:\n              recommendations:\n                - github.com/hashicorp/consul-net-rpc/net-rpc-msgpackrpc\n          - github.com/hashicorp/go-msgpack:\n              recommendations:\n                - github.com/hashicorp/consul-net-rpc/go-msgpack\n          - github.com/golang/protobuf:\n              recommendations:\n                - google.golang.org/protobuf\n    govet:\n      disable:\n        - fieldalignment\n        - nilness\n        - shadow\n        - unusedwrite\n        - printf\n      enable-all: true\n  exclusions:\n    generated: lax\n    rules:\n      - linters:\n          - staticcheck\n        text: 'SA9004:'\n      - linters:\n          - staticcheck\n        text: 'SA1006:'\n      - linters:\n          - staticcheck\n        text: 'SA1019: \"io/ioutil\" has been deprecated since Go 1.16'\n      - linters:\n          - staticcheck\n        path: (agent/grpc-external|agent/grpc-internal)\n        text: 'SA1019:'\n      - linters:\n          - unparam\n        text: always receives\n      - linte",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/.golangci.yml",
    "is_test_file": false
  },
  "Makefile": {
    "status": "modified",
    "patch": "@@ -10,7 +10,7 @@ GO_MODULES := $(shell find . -name go.mod -exec dirname {} \\; | grep -v \"proto-g\n # These version variables can either be a valid string for \"go install <module>@<version>\"\n # or the string @DEV to imply use what is currently installed locally.\n ###\n-GOLANGCI_LINT_VERSION='v1.64.8'\n+GOLANGCI_LINT_VERSION='v2.4.0'\n MOCKERY_VERSION='v3.5.2'\n BUF_VERSION='v1.26.0'\n ",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "",
    "imports": [],
    "full_content": "# For documentation on building consul from source, refer to:\n# https://developer.hashicorp.com/docs/install#compiling-from-source\n\nSHELL = bash\n\n\nGO_MODULES := $(shell find . -name go.mod -exec dirname {} \\; | grep -v \"proto-gen-rpc-glue/e2e\" | sort)\n\n###\n# These version variables can either be a valid string for \"go install <module>@<version>\"\n# or the string @DEV to imply use what is currently installed locally.\n###\nGOLANGCI_LINT_VERSION='v2.4.0'\nMOCKERY_VERSION='v3.5.2'\nBUF_VERSION='v1.26.0'\n\nPROTOC_GEN_GO_GRPC_VERSION='v1.5.1'\nMOG_VERSION='74a24e5f2782c2421cc6335c478686f62e9a0688'\nPROTOC_GO_INJECT_TAG_VERSION='v1.3.0'\nPROTOC_GEN_GO_BINARY_VERSION='v0.1.0'\nDEEP_COPY_VERSION='e112476c0181d3d69067bac191f9b6bcda2ce812'\nCOPYWRITE_TOOL_VERSION='v0.16.4'\nLINT_CONSUL_RETRY_VERSION='v1.4.0'\n# Go imports formatter\nGCI_VERSION='v0.11.2'\n\nMOCKED_PB_DIRS= pbdns\n\nGOTAGS ?=\nGOPATH=$(shell go env GOPATH)\nGOARCH?=$(shell go env GOARCH)\nMAIN_GOPATH=$(shell go env GOPATH | cut -d: -f1)\n\nexport PATH := $(PWD)/bin:$(GOPATH)/bin:$(PATH)\n\n# Get the git commit\nGIT_COMMIT?=$(shell git rev-parse --short HEAD)\nGIT_COMMIT_YEAR?=$(shell git show -s --format=%cd --date=format:%Y HEAD)\nGIT_DIRTY?=$(shell test -n \"`git status --porcelain`\" && echo \"+CHANGES\" || true)\nGIT_IMPORT=github.com/hashicorp/consul/version\nDATE_FORMAT=\"%Y-%m-%dT%H:%M:%SZ\" # it's tricky to do an RFC3339 format in a cross platform way, so we hardcode UTC\nGIT_DATE=$(shell $(CURDIR)/build-support/scripts/build-date.sh) # we're using this for build date because it's stable across platform builds\nGOLDFLAGS=-X $(GIT_IMPORT).GitCommit=$(GIT_COMMIT)$(GIT_DIRTY) -X $(GIT_IMPORT).BuildDate=$(GIT_DATE)\n\nGOTESTSUM_PATH?=$(shell command -v gotestsum)\n\nifeq ($(FORCE_REBUILD),1)\nNOCACHE=--no-cache\nelse\nNOCACHE=\nendif\n\nDOCKER_BUILD_QUIET?=1\nifeq (${DOCKER_BUILD_QUIET},1)\nQUIET=-q\nelse\nQUIET=\nendif\n\nifeq (\"$(GOTAGS)\",\"\")\nCONSUL_COMPAT_TEST_IMAGE=hashicorp/consul\nelse\nCONSUL_COMPAT_TEST_IMAGE=hashicorp/consul-enterprise\nendif\n\nCONSUL_DEV",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/Makefile",
    "is_test_file": false
  },
  "acl/acl_ce.go": {
    "status": "modified",
    "patch": "@@ -32,6 +32,4 @@ type EnterpriseConfig struct {\n \t// no fields in CE\n }\n \n-func (_ *EnterpriseConfig) Close() {\n-\t// do nothing\n-}\n+func (*EnterpriseConfig) Close() {}",
    "additions": 1,
    "deletions": 3,
    "changes": 4,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage acl\n\nconst (\n\tWildcardPartitionName = \"\"\n\tDefaultPartitionName  = \"\"\n\t// NonEmptyDefaultPartitionName is the name of the default partition that is\n\t// not empty.  An example of this being supplied is when a partition is specified\n\t// in the request for DNS by consul-dataplane.  This has been added to support\n\t// DNS v1.5, which needs to be compatible with the original DNS subsystem which\n\t// supports partition being \"default\" or empty.  Otherwise, use DefaultPartitionName.\n\tNonEmptyDefaultPartitionName = \"default\"\n\n\t// DefaultNamespaceName is used to mimic the behavior in consul/structs/intention.go,\n\t// where we define IntentionDefaultNamespace as 'default' and so we use the same here.\n\t// This is a little bit strange; one might want it to be \"\" like DefaultPartitionName.\n\tDefaultNamespaceName = \"default\"\n\n\t// EmptyNamespaceName is the name of the default partition that is an empty string.\n\t// An example of this being supplied is when a namespace is specifiedDNS v1.\n\t// EmptyNamespaceName has been added to support DNS v1.5, which needs to be\n\t// compatible with the original DNS subsystem which supports partition being \"default\" or empty.\n\t// Otherwise, use DefaultNamespaceName.\n\tEmptyNamespaceName = \"\"\n)\n\ntype EnterpriseConfig struct {\n\t// no fields in CE\n}\n\nfunc (*EnterpriseConfig) Close() {}\n",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/acl%2Facl_ce.go",
    "is_test_file": false
  },
  "acl/enterprisemeta_ce.go": {
    "status": "modified",
    "patch": "@@ -117,7 +117,7 @@ func NewEnterpriseMetaWithPartition(_, _ string) EnterpriseMeta {\n }\n \n // FillAuthzContext stub\n-func (_ *EnterpriseMeta) FillAuthzContext(_ *AuthorizerContext) {}\n+func (*EnterpriseMeta) FillAuthzContext(_ *AuthorizerContext) {}\n \n func NormalizeNamespace(_ string) string {\n \treturn \"\"",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage acl\n\nimport \"hash\"\n\nvar emptyEnterpriseMeta = EnterpriseMeta{}\n\n// EnterpriseMeta stub\ntype EnterpriseMeta struct{}\n\nfunc (m *EnterpriseMeta) ToEnterprisePolicyMeta() *EnterprisePolicyMeta {\n\treturn nil\n}\n\nfunc DefaultEnterpriseMeta() *EnterpriseMeta {\n\treturn &EnterpriseMeta{}\n}\n\nfunc WildcardEnterpriseMeta() *EnterpriseMeta {\n\treturn &EnterpriseMeta{}\n}\n\nfunc (m *EnterpriseMeta) EstimateSize() int {\n\treturn 0\n}\n\nfunc (m *EnterpriseMeta) AddToHash(_ hash.Hash, _ bool) {\n\t// do nothing\n}\n\nfunc (m *EnterpriseMeta) PartitionOrDefault() string {\n\treturn \"default\"\n}\n\nfunc EqualPartitions(_, _ string) bool {\n\treturn true\n}\n\nfunc IsDefaultPartition(partition string) bool {\n\treturn true\n}\n\nfunc PartitionOrDefault(_ string) string {\n\treturn \"default\"\n}\n\nfunc (m *EnterpriseMeta) PartitionOrEmpty() string {\n\treturn \"\"\n}\n\nfunc (m *EnterpriseMeta) InDefaultPartition() bool {\n\treturn true\n}\n\nfunc (m *EnterpriseMeta) NamespaceOrDefault() string {\n\treturn DefaultNamespaceName\n}\n\nfunc EqualNamespaces(_, _ string) bool {\n\treturn true\n}\n\nfunc NamespaceOrDefault(_ string) string {\n\treturn DefaultNamespaceName\n}\n\nfunc (m *EnterpriseMeta) NamespaceOrEmpty() string {\n\treturn \"\"\n}\n\nfunc (m *EnterpriseMeta) InDefaultNamespace() bool {\n\treturn true\n}\n\nfunc (m *EnterpriseMeta) Merge(_ *EnterpriseMeta) {\n\t// do nothing\n}\n\nfunc (m *EnterpriseMeta) MergeNoWildcard(_ *EnterpriseMeta) {\n\t// do nothing\n}\n\nfunc (*EnterpriseMeta) Normalize()          {}\nfunc (*EnterpriseMeta) NormalizePartition() {}\nfunc (*EnterpriseMeta) NormalizeNamespace() {}\n\nfunc (m *EnterpriseMeta) Matches(_ *EnterpriseMeta) bool {\n\treturn true\n}\n\nfunc (m *EnterpriseMeta) IsSame(_ *EnterpriseMeta) bool {\n\treturn true\n}\n\nfunc (m *EnterpriseMeta) LessThan(_ *EnterpriseMeta) bool {\n\treturn false\n}\n\nfunc (m *EnterpriseMeta) WithWildcardNamespace() *EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\nfunc (m *EnterpriseMeta) UnsetPart",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/acl%2Fenterprisemeta_ce.go",
    "is_test_file": false
  },
  "agent/acl_endpoint.go": {
    "status": "modified",
    "patch": "@@ -26,10 +26,7 @@ var aclDisabled = HTTPError{StatusCode: http.StatusUnauthorized, Reason: \"ACL su\n // checkACLDisabled will return a standard response if ACLs are disabled. This\n // returns true if they are disabled and we should not continue.\n func (s *HTTPHandlers) checkACLDisabled() bool {\n-\tif s.agent.config.ACLsEnabled {\n-\t\treturn false\n-\t}\n-\treturn true\n+\treturn !(s.agent.config.ACLsEnabled)\n }\n \n // ACLBootstrap is used to perform a one-time ACL bootstrap operation on",
    "additions": 1,
    "deletions": 4,
    "changes": 5,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage agent\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n\t\"github.com/hashicorp/consul/api\"\n\t\"github.com/hashicorp/consul/lib\"\n)\n\n// aclCreateResponse is used to wrap the ACL ID\ntype aclBootstrapResponse struct {\n\tID string\n\tstructs.ACLToken\n}\n\nvar aclDisabled = HTTPError{StatusCode: http.StatusUnauthorized, Reason: \"ACL support disabled\"}\n\n// checkACLDisabled will return a standard response if ACLs are disabled. This\n// returns true if they are disabled and we should not continue.\nfunc (s *HTTPHandlers) checkACLDisabled() bool {\n\treturn !(s.agent.config.ACLsEnabled)\n}\n\n// ACLBootstrap is used to perform a one-time ACL bootstrap operation on\n// a cluster to get the first management token.\nfunc (s *HTTPHandlers) ACLBootstrap(resp http.ResponseWriter, req *http.Request) (interface{}, error) {\n\tif s.checkACLDisabled() {\n\t\treturn nil, aclDisabled\n\t}\n\n\targs := structs.ACLInitialTokenBootstrapRequest{\n\t\tDatacenter: s.agent.config.Datacenter,\n\t}\n\n\t// Handle optional request body\n\tif req.ContentLength > 0 {\n\t\tvar bootstrapSecretRequest api.BootstrapRequest\n\t\tif err := lib.DecodeJSON(req.Body, &bootstrapSecretRequest); err != nil {\n\t\t\treturn nil, HTTPError{StatusCode: http.StatusBadRequest, Reason: fmt.Sprintf(\"Request decoding failed: %v\", err)}\n\t\t}\n\t\targs.BootstrapSecret = bootstrapSecretRequest.BootstrapSecret\n\t}\n\n\tvar out structs.ACLToken\n\terr := s.agent.RPC(req.Context(), \"ACL.BootstrapTokens\", &args, &out)\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), structs.ACLBootstrapNotAllowedErr.Error()) {\n\t\t\treturn nil, acl.PermissionDeniedError{Cause: err.Error()}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn &aclBootstrapResponse{ID: out.SecretID, ACLToken: out}, nil\n}\n\nfunc (s *HTTPHandlers) ACLReplicationStatus(resp http.ResponseWriter, req *http.Request) (interface{}, error) {\n\tif s.checkACLDisabled() {\n\t\treturn",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Facl_endpoint.go",
    "is_test_file": false
  },
  "agent/acl_endpoint_test.go": {
    "status": "modified",
    "patch": "@@ -34,10 +34,7 @@ import (\n \n func isHTTPBadRequest(err error) bool {\n \tif err, ok := err.(HTTPError); ok {\n-\t\tif err.StatusCode != 400 {\n-\t\t\treturn false\n-\t\t}\n-\t\treturn true\n+\t\treturn err.StatusCode == http.StatusBadRequest\n \t}\n \treturn false\n }",
    "additions": 1,
    "deletions": 4,
    "changes": 5,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage agent\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-jose/go-jose/v3/jwt\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/agent/consul/authmethod/testauth\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n\t\"github.com/hashicorp/consul/api\"\n\t\"github.com/hashicorp/consul/internal/go-sso/oidcauth/oidcauthtest\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/testrpc\"\n)\n\n// NOTE: The tests contained herein are designed to test the HTTP API\n//       They are not intended to thoroughly test the backing RPC\n//       functionality as that will be done with other tests.\n\nfunc isHTTPBadRequest(err error) bool {\n\tif err, ok := err.(HTTPError); ok {\n\t\treturn err.StatusCode == http.StatusBadRequest\n\t}\n\treturn false\n}\n\nfunc TestACL_Disabled_Response(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\tt.Parallel()\n\ta := NewTestAgent(t, \"\")\n\tdefer a.Shutdown()\n\n\ttype testCase struct {\n\t\tname string\n\t\tfn   func(resp http.ResponseWriter, req *http.Request) (interface{}, error)\n\t}\n\n\ttests := []testCase{\n\t\t{\"ACLBootstrap\", a.srv.ACLBootstrap},\n\t\t{\"ACLReplicationStatus\", a.srv.ACLReplicationStatus},\n\t\t{\"AgentToken\", a.srv.AgentToken}, // See TestAgent_Token\n\t\t{\"ACLPolicyList\", a.srv.ACLPolicyList},\n\t\t{\"ACLPolicyCRUD\", a.srv.ACLPolicyCRUD},\n\t\t{\"ACLPolicyCreate\", a.srv.ACLPolicyCreate},\n\t\t{\"ACLTokenList\", a.srv.ACLTokenList},\n\t\t{\"ACLTokenCreate\", a.srv.ACLTokenCreate},\n\t\t{\"ACLTokenSelf\", a.srv.ACLTokenSelf},\n\t\t{\"ACLTokenCRUD\", a.srv.ACLTokenCRUD},\n\t\t{\"ACLRoleList\", a.srv.ACLRoleList},\n\t\t{\"ACLRoleCreate\", a.srv.ACLRoleCreate},\n\t\t{\"ACLRoleCRUD\", a.srv.ACLRoleCRUD},\n\t\t{\"ACLBindingRuleList\", a.srv.ACLBindingRuleList},\n\t\t{\"ACLBindingRuleCreate\", a.srv.ACLBindingRuleCreate},\n\t\t{\"ACLBindingRuleCRUD\"",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Facl_endpoint_test.go",
    "is_test_file": true
  },
  "agent/agent.go": {
    "status": "modified",
    "patch": "@@ -4216,10 +4216,8 @@ func revertStaticConfig(oldCfg tlsutil.ProtocolConfig, newCfg tlsutil.ProtocolCo\n \tnewOldcfg := newCfg\n \tnewOldcfg.CertFile = oldCfg.CertFile\n \tnewOldcfg.KeyFile = oldCfg.KeyFile\n-\tif !reflect.DeepEqual(newOldcfg, oldCfg) {\n-\t\treturn true\n-\t}\n-\treturn false\n+\n+\treturn !reflect.DeepEqual(newOldcfg, oldCfg)\n }\n \n // reloadConfigInternal is mainly needed for some unit tests. Instead of parsing",
    "additions": 2,
    "deletions": 4,
    "changes": 6,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage agent\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/armon/go-metrics\"\n\t\"github.com/armon/go-metrics/prometheus\"\n\t\"github.com/rboyer/safeio\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/keepalive\"\n\n\t\"github.com/hashicorp/go-connlimit\"\n\t\"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-memdb\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/hashicorp/hcp-scada-provider/capability\"\n\t\"github.com/hashicorp/raft\"\n\t\"github.com/hashicorp/serf/serf\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/acl/resolver\"\n\t\"github.com/hashicorp/consul/agent/ae\"\n\t\"github.com/hashicorp/consul/agent/cache\"\n\tcachetype \"github.com/hashicorp/consul/agent/cache-types\"\n\t\"github.com/hashicorp/consul/agent/checks\"\n\t\"github.com/hashicorp/consul/agent/config\"\n\t\"github.com/hashicorp/consul/agent/consul\"\n\trpcRate \"github.com/hashicorp/consul/agent/consul/rate\"\n\t\"github.com/hashicorp/consul/agent/consul/servercert\"\n\texternal \"github.com/hashicorp/consul/agent/grpc-external\"\n\tgrpcDNS \"github.com/hashicorp/consul/agent/grpc-external/services/dns\"\n\tmiddleware \"github.com/hashicorp/consul/agent/grpc-middleware\"\n\t\"github.com/hashicorp/consul/agent/hcp/scada\"\n\t\"github.com/hashicorp/consul/agent/leafcert\"\n\t\"github.com/hashicorp/consul/agent/local\"\n\t\"github.com/hashicorp/consul/agent/proxycfg\"\n\tproxycfgglue \"github.com/hashicorp/consul/agent/proxycfg-glue\"\n\tcatalogproxycfg \"github.com/hashicorp/consul/agent/proxycfg-sources/catalog\"\n\tlocalproxycfg \"github.com/hashicorp/consul/agent/proxycfg-sources/local\"\n\t\"github.com/hashicorp/consul/agent/rpcclient\"\n\t\"github.com/hashicorp/consul/agent/rpcclient/configentry\"\n\t\"github.com/hashicorp/consul/agent/rpcclient/health\"\n\t\"github.com/hashicorp/co",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fagent.go",
    "is_test_file": false
  },
  "agent/checks/check_test.go": {
    "status": "modified",
    "patch": "@@ -1198,11 +1198,10 @@ func mockUDPServer(ctx context.Context, network string, port int) {\n \t\t}\n \t}()\n \n-\tselect {\n-\tcase <-ctx.Done():\n-\t\tfmt.Println(\"cancelled\")\n-\t\tclose(chClose)\n-\t}\n+\t<-ctx.Done()\n+\tfmt.Println(\"cancelled\")\n+\tclose(chClose)\n+\n \twg.Wait()\n }\n \n@@ -1366,7 +1365,7 @@ func TestCheckH2PING(t *testing.T) {\n }\n \n func TestCheckH2PING_TLS_BadVerify(t *testing.T) {\n-\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { return })\n+\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n \tserver := httptest.NewUnstartedServer(handler)\n \tserver.EnableHTTP2 = true\n \tserver.StartTLS()\n@@ -1468,7 +1467,7 @@ func TestCheckH2CPING(t *testing.T) {\n \n \tfor _, tt := range tests {\n \t\tt.Run(tt.desc, func(t *testing.T) {\n-\t\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { return })\n+\t\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n \t\t\th2chandler := h2c.NewHandler(handler, &http2.Server{})\n \t\t\tserver := httptest.NewUnstartedServer(h2chandler)\n \t\t\tserver.Config.ReadTimeout = tt.connTimeout",
    "additions": 6,
    "deletions": 7,
    "changes": 13,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage checks\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n\n\t\"github.com/hashicorp/go-uuid\"\n\n\t\"github.com/hashicorp/consul/agent/mock\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n\t\"github.com/hashicorp/consul/api\"\n\t\"github.com/hashicorp/consul/sdk/freeport\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\nfunc uniqueID() string {\n\tid, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn id\n}\n\nfunc TestCheckMonitor_Script(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\ttests := []struct {\n\t\tscript, status string\n\t}{\n\t\t{\"exit 0\", \"passing\"},\n\t\t{\"exit 1\", \"warning\"},\n\t\t{\"exit 2\", \"critical\"},\n\t\t{\"foobarbaz\", \"critical\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.status, func(t *testing.T) {\n\t\t\tnotif := mock.NewNotify()\n\t\t\tlogger := testutil.Logger(t)\n\t\t\tstatusHandler := NewStatusHandler(notif, logger, 0, 0, 0)\n\n\t\t\tcid := structs.NewCheckID(\"foo\", nil)\n\t\t\tcheck := &CheckMonitor{\n\t\t\t\tNotify:        notif,\n\t\t\t\tCheckID:       cid,\n\t\t\t\tScript:        tt.script,\n\t\t\t\tInterval:      25 * time.Millisecond,\n\t\t\t\tOutputMaxSize: DefaultBufSize,\n\t\t\t\tLogger:        logger,\n\t\t\t\tStatusHandler: statusHandler,\n\t\t\t}\n\t\t\tcheck.Start()\n\t\t\tdefer check.Stop()\n\t\t\tretry.Run(t, func(r *retry.R) {\n\t\t\t\tif got, want := notif.Updates(cid), 2; got < want {\n\t\t\t\t\tr.Fatalf(\"got %d updates want at least %d\", got, want)\n\t\t\t\t}\n\t\t\t\tif got, want := notif.State(cid), tt.status; got != want {\n\t\t\t\t\tr.Fatalf(\"got state %q want %q\", got, want)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestCheckMonitor_Args(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"too slow for testing.Short\")\n\t}\n\n\ttests := []struct {\n\t\targs   []string\n\t\tstatus string\n\t}{\n\t\t{[]stri",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fchecks%2Fcheck_test.go",
    "is_test_file": true
  },
  "agent/config/config_ce.go": {
    "status": "modified",
    "patch": "@@ -13,6 +13,6 @@ import (\n // EnterpriseMeta stub\n type EnterpriseMeta struct{}\n \n-func (_ *EnterpriseMeta) ToStructs() acl.EnterpriseMeta {\n+func (*EnterpriseMeta) ToStructs() acl.EnterpriseMeta {\n \treturn *structs.DefaultEnterpriseMetaInDefaultPartition()\n }",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage config\n\nimport (\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n)\n\n// EnterpriseMeta stub\ntype EnterpriseMeta struct{}\n\nfunc (*EnterpriseMeta) ToStructs() acl.EnterpriseMeta {\n\treturn *structs.DefaultEnterpriseMetaInDefaultPartition()\n}\n",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fconfig%2Fconfig_ce.go",
    "is_test_file": false
  },
  "agent/connect/ca/provider_aws_test.go": {
    "status": "modified",
    "patch": "@@ -112,7 +112,7 @@ func TestAWSBootstrapAndSignSecondary(t *testing.T) {\n \trootPEM, err := p1.GenerateCAChain()\n \trequire.NoError(t, err)\n \n-\tp2 := testAWSProvider(t, testProviderConfigSecondary(t, nil))\n+\tp2 := testAWSProvider(t, testProviderConfigSecondary(nil))\n \tdefer p2.Cleanup(true, nil)\n \n \ttestSignIntermediateCrossDC(t, p1, p2)\n@@ -202,7 +202,7 @@ func TestAWSBootstrapAndSignSecondary(t *testing.T) {\n \t\tnewIntPEM := strings.TrimSuffix(intPEM, \"\\n\")\n \t\tnewRootPEM := strings.TrimSuffix(rootPEM, \"\\n\")\n \n-\t\tcfg2 := testProviderConfigSecondary(t, map[string]interface{}{\n+\t\tcfg2 := testProviderConfigSecondary(map[string]interface{}{\n \t\t\t\"ExistingARN\": p2State[AWSStateCAARNKey],\n \t\t})\n \t\tp2 = testAWSProvider(t, cfg2)\n@@ -232,7 +232,7 @@ func TestAWSBootstrapAndSignSecondaryConsul(t *testing.T) {\n \t\t_, err := p1.GenerateCAChain()\n \t\trequire.NoError(t, err)\n \n-\t\tp2 := testAWSProvider(t, testProviderConfigSecondary(t, nil))\n+\t\tp2 := testAWSProvider(t, testProviderConfigSecondary(nil))\n \t\tdefer p2.Cleanup(true, nil)\n \n \t\ttestSignIntermediateCrossDC(t, p1, p2)\n@@ -437,7 +437,7 @@ func testProviderConfigPrimary(cfg map[string]interface{}) ProviderConfig {\n \t}\n }\n \n-func testProviderConfigSecondary(t *testing.T, cfg map[string]interface{}) ProviderConfig {\n+func testProviderConfigSecondary(cfg map[string]interface{}) ProviderConfig {\n \tc := testProviderConfigPrimary(cfg)\n \tc.IsPrimary = false\n \tc.Datacenter = \"dc2\"",
    "additions": 4,
    "deletions": 4,
    "changes": 8,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage ca\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/service/acmpca\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/agent/connect\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n)\n\n// skipIfAWSNotConfigured skips the test unless ENABLE_AWS_PCA_TESTS=true.\n//\n// These tests are not run in CI.  If you are making changes to the AWS provider\n// you probably want to run these tests locally. The tests will run using any\n// credentials available to the AWS SDK. See\n// https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials\n// for a list of options.\nfunc skipIfAWSNotConfigured(t *testing.T) {\n\tenabled := os.Getenv(\"ENABLE_AWS_PCA_TESTS\")\n\tok, err := strconv.ParseBool(enabled)\n\tif err != nil || !ok {\n\t\tt.Skip(\"Skipping because AWS tests are not enabled\")\n\t}\n}\n\nfunc TestAWSBootstrapAndSignPrimary(t *testing.T) {\n\t// Note not parallel since we could easily hit AWS limits of too many CAs if\n\t// all of these tests run at once.\n\tskipIfAWSNotConfigured(t)\n\n\tfor _, tc := range KeyTestCases {\n\t\ttc := tc\n\t\tt.Run(tc.Desc, func(t *testing.T) {\n\t\t\tcfg := map[string]interface{}{\n\t\t\t\t\"PrivateKeyType\": tc.KeyType,\n\t\t\t\t\"PrivateKeyBits\": tc.KeyBits,\n\t\t\t\t\"RootCertTTL\":    \"8761h\",\n\t\t\t}\n\t\t\tprovider := testAWSProvider(t, testProviderConfigPrimary(cfg))\n\t\t\tdefer provider.Cleanup(true, nil)\n\n\t\t\trootPEM, err := provider.GenerateCAChain()\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Ensure they use the right key type\n\t\t\trootCert, err := connect.ParseCert(rootPEM)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tkeyType, keyBits, err := connect.KeyInfoFromCert(rootCert)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.KeyType, keyType)\n\t\t\trequire.Equal(t, tc.KeyBits, keyBits)\n\n\t\t\t// Ensure that the root cert ttl is withing the configured value\n\t\t\t// computation is similar to how we are passing the TTL thru the aws cl",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fconnect%2Fca%2Fprovider_aws_test.go",
    "is_test_file": true
  },
  "agent/grpc-external/services/resource/server_ce_test.go": {
    "status": "modified",
    "patch": "@@ -7,10 +7,6 @@ package resource_test\n \n import \"github.com/hashicorp/consul/acl\"\n \n-func fillEntMeta(entMeta *acl.EnterpriseMeta) {\n-\treturn\n-}\n+func fillEntMeta(_ *acl.EnterpriseMeta) {}\n \n-func fillAuthorizerContext(authzContext *acl.AuthorizerContext) {\n-\treturn\n-}\n+func fillAuthorizerContext(_ *acl.AuthorizerContext) {}",
    "additions": 2,
    "deletions": 6,
    "changes": 8,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage resource_test\n\nimport \"github.com/hashicorp/consul/acl\"\n\nfunc fillEntMeta(_ *acl.EnterpriseMeta) {}\n\nfunc fillAuthorizerContext(_ *acl.AuthorizerContext) {}\n",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fgrpc-external%2Fservices%2Fresource%2Fserver_ce_test.go",
    "is_test_file": true
  },
  "agent/structs/acl_ce.go": {
    "status": "modified",
    "patch": "@@ -54,22 +54,18 @@ type ACLAuthMethodEnterpriseFields struct{}\n \n type ACLAuthMethodEnterpriseMeta struct{}\n \n-func (_ *ACLAuthMethodEnterpriseMeta) FillWithEnterpriseMeta(_ *acl.EnterpriseMeta) {\n+func (*ACLAuthMethodEnterpriseMeta) FillWithEnterpriseMeta(_ *acl.EnterpriseMeta) {\n \t// do nothing\n }\n \n-func (_ *ACLAuthMethodEnterpriseMeta) ToEnterpriseMeta() *acl.EnterpriseMeta {\n+func (*ACLAuthMethodEnterpriseMeta) ToEnterpriseMeta() *acl.EnterpriseMeta {\n \treturn DefaultEnterpriseMetaInDefaultPartition()\n }\n \n func aclServiceIdentityRules(svc string, _ *acl.EnterpriseMeta) string {\n \treturn fmt.Sprintf(aclPolicyTemplateServiceIdentity, svc)\n }\n \n-func aclNodeIdentityRules(node string, _ *acl.EnterpriseMeta) string {\n-\treturn fmt.Sprintf(aclPolicyTemplateNodeIdentity, node)\n-}\n-\n func (p *ACLPolicy) EnterprisePolicyMeta() *acl.EnterprisePolicyMeta {\n \treturn nil\n }",
    "additions": 2,
    "deletions": 6,
    "changes": 8,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage structs\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/hashicorp/consul/acl\"\n)\n\nconst (\n\tEnterpriseACLPolicyGlobalManagement = \"\"\n\tEnterpriseACLPolicyGlobalReadOnly   = \"\"\n\n\t// aclPolicyTemplateServiceIdentity is the template used for synthesizing\n\t// policies for service identities.\n\taclPolicyTemplateServiceIdentity = `\nservice \"%[1]s\" {\n\tpolicy = \"write\"\n}\nservice \"%[1]s-sidecar-proxy\" {\n\tpolicy = \"write\"\n}\nservice_prefix \"\" {\n\tpolicy = \"read\"\n}\nnode_prefix \"\" {\n\tpolicy = \"read\"\n}`\n\n\t// A typical Consul node requires two permissions for itself.\n\t// node:write\n\t//    - register itself in the catalog\n\t//    - update its network coordinates\n\t//    - potentially used to delete services during anti-entropy\n\t// service:read\n\t//    - used during anti-entropy to discover all services that\n\t//      are registered to the node. That way the node can diff\n\t//      its local state against an accurate depiction of the\n\t//      remote state.\n\taclPolicyTemplateNodeIdentity = `\nnode \"%[1]s\" {\n\tpolicy = \"write\"\n}\nservice_prefix \"\" {\n\tpolicy = \"read\"\n}`\n)\n\ntype ACLAuthMethodEnterpriseFields struct{}\n\ntype ACLAuthMethodEnterpriseMeta struct{}\n\nfunc (*ACLAuthMethodEnterpriseMeta) FillWithEnterpriseMeta(_ *acl.EnterpriseMeta) {\n\t// do nothing\n}\n\nfunc (*ACLAuthMethodEnterpriseMeta) ToEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn DefaultEnterpriseMetaInDefaultPartition()\n}\n\nfunc aclServiceIdentityRules(svc string, _ *acl.EnterpriseMeta) string {\n\treturn fmt.Sprintf(aclPolicyTemplateServiceIdentity, svc)\n}\n\nfunc (p *ACLPolicy) EnterprisePolicyMeta() *acl.EnterprisePolicyMeta {\n\treturn nil\n}\n\nfunc (t *ACLToken) NodeIdentityList() []*ACLNodeIdentity {\n\tif len(t.NodeIdentities) == 0 {\n\t\treturn nil\n\t}\n\n\tout := make([]*ACLNodeIdentity, 0, len(t.NodeIdentities))\n\tfor _, n := range t.NodeIdentities {\n\t\tout = append(out, n.Clone())\n\t}\n\treturn out\n}\n\nfunc (r *ACLRole) NodeIdentityList() []*ACLNodeIdentity {\n\tif ",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fstructs%2Facl_ce.go",
    "is_test_file": false
  },
  "agent/structs/aclfilter/filter.go": {
    "status": "modified",
    "patch": "@@ -178,10 +178,8 @@ func (f *Filter) allowGateway(gs *structs.GatewayService) bool {\n \t}\n \n \tgs.Service.FillAuthzContext(&authzContext)\n-\tif !f.allowService(gs.Service.Name, &authzContext) {\n-\t\treturn false\n-\t}\n-\treturn true\n+\n+\treturn f.allowService(gs.Service.Name, &authzContext)\n }\n \n // allowService is used to determine if a service is accessible for an ACL.",
    "additions": 2,
    "deletions": 4,
    "changes": 6,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage aclfilter\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/hashicorp/go-hclog\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/agent/structs\"\n)\n\nconst (\n\t// RedactedToken is shown in structures with embedded tokens when they\n\t// are not allowed to be displayed.\n\tRedactedToken = \"<hidden>\"\n)\n\n// Filter is used to filter results based on ACL rules.\ntype Filter struct {\n\tauthorizer acl.Authorizer\n\tlogger     hclog.Logger\n}\n\n// New constructs a Filter with the given authorizer.\nfunc New(authorizer acl.Authorizer, logger hclog.Logger) *Filter {\n\tif logger == nil {\n\t\tlogger = hclog.NewNullLogger()\n\t}\n\treturn &Filter{authorizer, logger}\n}\n\n// Filter the given subject in-place.\nfunc (f *Filter) Filter(subject any) {\n\tswitch v := subject.(type) {\n\tcase *structs.CheckServiceNodes:\n\t\tf.filterCheckServiceNodes(v)\n\n\tcase *structs.IndexedCheckServiceNodes:\n\t\tv.ResultsFilteredByACLs = f.filterCheckServiceNodes(&v.Nodes)\n\n\tcase *structs.PreparedQueryExecuteResponse:\n\t\tv.ResultsFilteredByACLs = f.filterCheckServiceNodes(&v.Nodes)\n\n\tcase *structs.IndexedServiceTopology:\n\t\tfiltered := f.filterServiceTopology(v.ServiceTopology)\n\t\tif filtered {\n\t\t\tv.FilteredByACLs = true\n\t\t\tv.ResultsFilteredByACLs = true\n\t\t}\n\n\tcase *structs.DatacenterIndexedCheckServiceNodes:\n\t\tv.ResultsFilteredByACLs = f.filterDatacenterCheckServiceNodes(&v.DatacenterNodes)\n\n\tcase *structs.IndexedCoordinates:\n\t\tv.ResultsFilteredByACLs = f.filterCoordinates(&v.Coordinates)\n\n\tcase *structs.IndexedHealthChecks:\n\t\tv.ResultsFilteredByACLs = f.filterHealthChecks(&v.HealthChecks)\n\n\tcase *structs.IndexedIntentions:\n\t\tv.ResultsFilteredByACLs = f.filterIntentions(&v.Intentions)\n\n\tcase *structs.IntentionQueryMatch:\n\t\tf.filterIntentionMatch(v)\n\n\tcase *structs.IndexedNodeDump:\n\t\tif f.filterNodeDump(&v.Dump) {\n\t\t\tv.ResultsFilteredByACLs = true\n\t\t}\n\t\tif f.filterNodeDump(&v.ImportedDump) {\n\t\t\tv.ResultsFilteredByACLs = true\n\t\t}\n\n\tcase *structs.IndexedService",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fstructs%2Faclfilter%2Ffilter.go",
    "is_test_file": false
  },
  "agent/structs/config_entry_jwt_provider_test.go": {
    "status": "modified",
    "patch": "@@ -20,8 +20,8 @@ func newTestAuthz(t *testing.T, src string) acl.Authorizer {\n \treturn authorizer\n }\n \n-var tenSeconds = 10 * time.Second\n-var hundredSeconds time.Duration = 100 * time.Second\n+var shortInterval = 10 * time.Second\n+var longInterval = 100 * time.Second\n var connectTimeout = time.Duration(5) * time.Second\n \n func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n@@ -215,8 +215,8 @@ func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n \t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n \t\t\t\t\t\tRetryPolicy: &JWKSRetryPolicy{\n \t\t\t\t\t\t\tRetryPolicyBackOff: &RetryPolicyBackOff{\n-\t\t\t\t\t\t\t\tBaseInterval: hundredSeconds,\n-\t\t\t\t\t\t\t\tMaxInterval:  tenSeconds,\n+\t\t\t\t\t\t\t\tBaseInterval: longInterval,\n+\t\t\t\t\t\t\t\tMaxInterval:  shortInterval,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t},\n@@ -318,8 +318,8 @@ func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n \t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n \t\t\t\t\t\tRetryPolicy: &JWKSRetryPolicy{\n \t\t\t\t\t\t\tRetryPolicyBackOff: &RetryPolicyBackOff{\n-\t\t\t\t\t\t\t\tBaseInterval: tenSeconds,\n-\t\t\t\t\t\t\t\tMaxInterval:  hundredSeconds,\n+\t\t\t\t\t\t\t\tBaseInterval: shortInterval,\n+\t\t\t\t\t\t\t\tMaxInterval:  longInterval,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t\tJWKSCluster: &JWKSCluster{\n@@ -359,8 +359,8 @@ func TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n \t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n \t\t\t\t\t\tRetryPolicy: &JWKSRetryPolicy{\n \t\t\t\t\t\t\tRetryPolicyBackOff: &RetryPolicyBackOff{\n-\t\t\t\t\t\t\t\tBaseInterval: tenSeconds,\n-\t\t\t\t\t\t\t\tMaxInterval:  hundredSeconds,\n+\t\t\t\t\t\t\t\tBaseInterval: shortInterval,\n+\t\t\t\t\t\t\t\tMaxInterval:  longInterval,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\n \t\t\t\t\t\tJWKSCluster: &JWKSCluster{",
    "additions": 8,
    "deletions": 8,
    "changes": 16,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage structs\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc newTestAuthz(t *testing.T, src string) acl.Authorizer {\n\tpolicy, err := acl.NewPolicyFromSource(src, nil, nil)\n\trequire.NoError(t, err)\n\n\tauthorizer, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)\n\trequire.NoError(t, err)\n\treturn authorizer\n}\n\nvar shortInterval = 10 * time.Second\nvar longInterval = 100 * time.Second\nvar connectTimeout = time.Duration(5) * time.Second\n\nfunc TestJWTProviderConfigEntry_ValidateAndNormalize(t *testing.T) {\n\tdefaultMeta := DefaultEnterpriseMetaInDefaultPartition()\n\n\tcases := map[string]configEntryTestcase{\n\t\t\"valid jwt-provider - local jwks\": {\n\t\t\tentry: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tLocal: &LocalJWKS{\n\t\t\t\t\t\tFilename: \"jwks.txt\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tLocal: &LocalJWKS{\n\t\t\t\t\t\tFilename: \"jwks.txt\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tClockSkewSeconds: DefaultClockSkewSeconds,\n\t\t\t\tEnterpriseMeta:   *defaultMeta,\n\t\t\t},\n\t\t},\n\t\t\"valid jwt-provider - remote jwks defaults\": {\n\t\t\tentry: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tRemote: &RemoteJWKS{\n\t\t\t\t\t\tFetchAsynchronously: true,\n\t\t\t\t\t\tURI:                 \"https://example.com/.well-known/jwks.json\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tLocations: []*JWTLocation{\n\t\t\t\t\t{\n\t\t\t\t\t\tHeader: &JWTLocationHeader{\n\t\t\t\t\t\t\tName: \"Authorization\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tForwarding: &JWTForwardingConfig{\n\t\t\t\t\tHeaderName: \"Some-Header\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: &JWTProviderConfigEntry{\n\t\t\t\tKind: JWTProvider,\n\t\t\t\tName: \"test-jwt-provider\",\n\t\t\t\tJSONWebKeySet: &JSONWebKeySet{\n\t\t\t\t\tRemote: &RemoteJWKS{\n\t\t\t\t\t\tFetchAsync",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fstructs%2Fconfig_entry_jwt_provider_test.go",
    "is_test_file": true
  },
  "agent/structs/intention_ce.go": {
    "status": "modified",
    "patch": "@@ -32,21 +32,21 @@ func (e *IntentionQueryExact) DestinationEnterpriseMeta() *acl.EnterpriseMeta {\n // FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n // extra parameters for ACL enforcement. In CE there is currently nothing\n // extra to be done.\n-func (_ *Intention) FillAuthzContext(_ *acl.AuthorizerContext, _ bool) {\n+func (*Intention) FillAuthzContext(_ *acl.AuthorizerContext, _ bool) {\n \t// do nothing\n }\n \n // FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n // extra parameters for ACL enforcement. In CE there is currently nothing\n // extra to be done.\n-func (_ *IntentionMatchEntry) FillAuthzContext(_ *acl.AuthorizerContext) {\n+func (*IntentionMatchEntry) FillAuthzContext(_ *acl.AuthorizerContext) {\n \t// do nothing\n }\n \n // FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n // extra parameters for ACL enforcement. In CE there is currently nothing\n // extra to be done.\n-func (_ *IntentionQueryCheck) FillAuthzContext(_ *acl.AuthorizerContext) {\n+func (*IntentionQueryCheck) FillAuthzContext(_ *acl.AuthorizerContext) {\n \t// do nothing\n }\n ",
    "additions": 3,
    "deletions": 3,
    "changes": 6,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage structs\n\nimport (\n\t\"github.com/hashicorp/consul/acl\"\n)\n\nfunc (ixn *Intention) SourceEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn DefaultEnterpriseMetaInDefaultPartition()\n}\n\nfunc (ixn *Intention) DestinationEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn DefaultEnterpriseMetaInDefaultPartition()\n}\n\nfunc (e *IntentionMatchEntry) GetEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn DefaultEnterpriseMetaInDefaultPartition()\n}\n\nfunc (e *IntentionQueryExact) SourceEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn DefaultEnterpriseMetaInDefaultPartition()\n}\n\nfunc (e *IntentionQueryExact) DestinationEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn DefaultEnterpriseMetaInDefaultPartition()\n}\n\n// FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n// extra parameters for ACL enforcement. In CE there is currently nothing\n// extra to be done.\nfunc (*Intention) FillAuthzContext(_ *acl.AuthorizerContext, _ bool) {\n\t// do nothing\n}\n\n// FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n// extra parameters for ACL enforcement. In CE there is currently nothing\n// extra to be done.\nfunc (*IntentionMatchEntry) FillAuthzContext(_ *acl.AuthorizerContext) {\n\t// do nothing\n}\n\n// FillAuthzContext can fill in an acl.AuthorizerContext object to setup\n// extra parameters for ACL enforcement. In CE there is currently nothing\n// extra to be done.\nfunc (*IntentionQueryCheck) FillAuthzContext(_ *acl.AuthorizerContext) {\n\t// do nothing\n}\n\n// FillPartitionAndNamespace will fill in empty source and destination partition/namespaces.\n// If fillDefault is true, all fields are defaulted when the given enterprise meta does not\n// specify them.\n//\n// fillDefault MUST be true on servers to ensure that all fields are populated on writes.\n// fillDefault MUST be false on clients so that servers can correctly fill in the\n// namespace/partition of the ACL token.\nfunc (ixn *Intenti",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fstructs%2Fintention_ce.go",
    "is_test_file": false
  },
  "agent/structs/structs_ce.go": {
    "status": "modified",
    "patch": "@@ -67,30 +67,30 @@ func (n *Node) OverridePartition(_ string) {\n \tn.Partition = \"\"\n }\n \n-func (_ *Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n func (n *NodeInfo) FillAuthzContext(ctx *acl.AuthorizerContext) {\n \tctx.Peer = n.PeerName\n }\n \n // FillAuthzContext stub\n-func (_ *DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n // FillAuthzContext stub\n-func (_ *RegisterRequest) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*RegisterRequest) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n-func (_ *RegisterRequest) GetEnterpriseMeta() *acl.EnterpriseMeta {\n+func (*RegisterRequest) GetEnterpriseMeta() *acl.EnterpriseMeta {\n \treturn nil\n }\n \n // CE Stub\n func (op *TxnNodeOp) FillAuthzContext(ctx *acl.AuthorizerContext) {}\n \n // CE Stub\n-func (_ *TxnServiceOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*TxnServiceOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n // CE Stub\n-func (_ *TxnCheckOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n+func (*TxnCheckOp) FillAuthzContext(_ *acl.AuthorizerContext) {}\n \n func NodeNameString(node string, _ *acl.EnterpriseMeta) string {\n \treturn node\n@@ -136,7 +136,7 @@ func (cid CheckID) String() string {\n \treturn string(cid.ID)\n }\n \n-func (_ *HealthCheck) Validate() error {\n+func (*HealthCheck) Validate() error {\n \treturn nil\n }\n ",
    "additions": 7,
    "deletions": 7,
    "changes": 14,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\n//go:build !consulent\n\npackage structs\n\nimport (\n\t\"github.com/hashicorp/consul/acl\"\n\t\"github.com/hashicorp/consul/types\"\n)\n\n// TODO(acl-move-enterprise-meta) sync this with enterprise\nvar emptyEnterpriseMeta = acl.EnterpriseMeta{}\n\n// TODO(partition): stop using this\nfunc NewEnterpriseMetaInDefaultPartition(_ string) acl.EnterpriseMeta {\n\treturn emptyEnterpriseMeta\n}\n\n// ReplicationEnterpriseMeta stub\nfunc ReplicationEnterpriseMeta() *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\n// TODO(partition): stop using this\nfunc WildcardEnterpriseMetaInDefaultPartition() *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\n// TODO(partition): stop using this\nfunc DefaultEnterpriseMetaInDefaultPartition() *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\n// DefaultEnterpriseMetaInPartition stub\nfunc DefaultEnterpriseMetaInPartition(_ string) *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\n// WildcardEnterpriseMetaInPartition stub\nfunc WildcardEnterpriseMetaInPartition(_ string) *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\nfunc NewEnterpriseMetaWithPartition(_, _ string) acl.EnterpriseMeta {\n\treturn emptyEnterpriseMeta\n}\n\nfunc NodeEnterpriseMetaInPartition(_ string) *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\n// TODO(partition): stop using this\nfunc NodeEnterpriseMetaInDefaultPartition() *acl.EnterpriseMeta {\n\treturn &emptyEnterpriseMeta\n}\n\nfunc (n *Node) FillAuthzContext(ctx *acl.AuthorizerContext) {\n\tif ctx == nil {\n\t\treturn\n\t}\n\tctx.Peer = n.PeerName\n}\n\nfunc (n *Node) OverridePartition(_ string) {\n\tn.Partition = \"\"\n}\n\nfunc (*Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}\n\nfunc (n *NodeInfo) FillAuthzContext(ctx *acl.AuthorizerContext) {\n\tctx.Peer = n.PeerName\n}\n\n// FillAuthzContext stub\nfunc (*DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}\n\n// FillAuthzContext stub\nfunc (*RegisterRequest) FillAuthzContext(_ *acl.AuthorizerContext) {}\n\nfunc (*Registe",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/agent%2Fstructs%2Fstructs_ce.go",
    "is_test_file": false
  },
  "api/agent_test.go": {
    "status": "modified",
    "patch": "@@ -1462,7 +1462,7 @@ func TestAPI_AgentMonitor(t *testing.T) {\n \t\t// Wait for the first log message and validate it\n \t\tselect {\n \t\tcase log := <-logCh:\n-\t\t\tif !(strings.Contains(log, \"[INFO]\") || strings.Contains(log, \"[DEBUG]\")) {\n+\t\t\tif !strings.Contains(log, \"[INFO]\") && !strings.Contains(log, \"[DEBUG]\") {\n \t\t\t\tr.Fatalf(\"bad: %q\", log)\n \t\t\t}\n \t\tcase <-time.After(10 * time.Second):",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/serf/serf\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\nfunc TestAPI_AgentSelf(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tagent := c.Agent()\n\n\tinfo, err := agent.Self()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tname := info[\"Config\"][\"NodeName\"].(string)\n\tif name == \"\" {\n\t\tt.Fatalf(\"bad: %v\", info)\n\t}\n}\n\nfunc TestAPI_AgentMetrics(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tagent := c.Agent()\n\ts.WaitForSerfCheck(t)\n\n\ttimer := &retry.Timer{Timeout: 10 * time.Second, Wait: 500 * time.Millisecond}\n\tretry.RunWith(timer, t, func(r *retry.R) {\n\t\tmetrics, err := agent.Metrics()\n\t\tif err != nil {\n\t\t\tr.Fatalf(\"err: %v\", err)\n\t\t}\n\t\thostname, err := os.Hostname()\n\t\tif err != nil {\n\t\t\tr.Fatalf(\"error determining hostname: %v\", err)\n\t\t}\n\t\tmetricName := fmt.Sprintf(\"consul.%s.runtime.alloc_bytes\", hostname)\n\t\tfor _, g := range metrics.Gauges {\n\t\t\tif g.Name == metricName {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tr.Fatalf(\"missing runtime metrics\")\n\t})\n}\n\nfunc TestAPI_AgentHost(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tagent := c.Agent()\n\ttimer := &retry.Timer{}\n\tretry.RunWith(timer, t, func(r *retry.R) {\n\t\thost, err := agent.Host()\n\t\tif err != nil {\n\t\t\tr.Fatalf(\"err: %v\", err)\n\t\t}\n\n\t\t// CollectionTime should exist on all responses\n\t\tif host[\"CollectionTime\"] == nil {\n\t\t\tr.Fatalf(\"missing host response\")\n\t\t}\n\t})\n}\n\nfunc TestAPI_AgentReload(t *testing.T) {\n\tt.Parallel()\n\n\t// Create our initial empty config file, to be overwritten later\n\tcfgDir := testutil.TempDir(t, \"consul-config\")\n\n\tcfgFilePath := filepath.Join(cfgDir,",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fagent_test.go",
    "is_test_file": true
  },
  "api/api.go": {
    "status": "modified",
    "patch": "@@ -646,9 +646,7 @@ func (c *Client) Headers() http.Header {\n \n \tret := make(http.Header)\n \tfor k, v := range c.headers {\n-\t\tfor _, val := range v {\n-\t\t\tret[k] = append(ret[k], val)\n-\t\t}\n+\t\tret[k] = append(ret[k], v...)\n \t}\n \n \treturn ret\n@@ -1312,7 +1310,7 @@ func generateUnexpectedResponseCodeError(resp *http.Response) error {\n \tio.Copy(&buf, resp.Body)\n \tcloseResponseBody(resp)\n \n-\ttrimmed := strings.TrimSpace(string(buf.Bytes()))\n+\ttrimmed := strings.TrimSpace(buf.String())\n \treturn StatusError{Code: resp.StatusCode, Body: trimmed}\n }\n ",
    "additions": 2,
    "deletions": 4,
    "changes": 6,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-cleanhttp\"\n\t\"github.com/hashicorp/go-hclog\"\n\t\"github.com/hashicorp/go-rootcerts\"\n)\n\nconst (\n\t// HTTPAddrEnvName defines an environment variable name which sets\n\t// the HTTP address if there is no -http-addr specified.\n\tHTTPAddrEnvName = \"CONSUL_HTTP_ADDR\"\n\n\t// HTTPTokenEnvName defines an environment variable name which sets\n\t// the HTTP token.\n\tHTTPTokenEnvName = \"CONSUL_HTTP_TOKEN\"\n\n\t// HTTPTokenFileEnvName defines an environment variable name which sets\n\t// the HTTP token file.\n\tHTTPTokenFileEnvName = \"CONSUL_HTTP_TOKEN_FILE\"\n\n\t// HTTPAuthEnvName defines an environment variable name which sets\n\t// the HTTP authentication header.\n\tHTTPAuthEnvName = \"CONSUL_HTTP_AUTH\"\n\n\t// HTTPSSLEnvName defines an environment variable name which sets\n\t// whether or not to use HTTPS.\n\tHTTPSSLEnvName = \"CONSUL_HTTP_SSL\"\n\n\t// HTTPCAFile defines an environment variable name which sets the\n\t// CA file to use for talking to Consul over TLS.\n\tHTTPCAFile = \"CONSUL_CACERT\"\n\n\t// HTTPCAPath defines an environment variable name which sets the\n\t// path to a directory of CA certs to use for talking to Consul over TLS.\n\tHTTPCAPath = \"CONSUL_CAPATH\"\n\n\t// HTTPClientCert defines an environment variable name which sets the\n\t// client cert file to use for talking to Consul over TLS.\n\tHTTPClientCert = \"CONSUL_CLIENT_CERT\"\n\n\t// HTTPClientKey defines an environment variable name which sets the\n\t// client key file to use for talking to Consul over TLS.\n\tHTTPClientKey = \"CONSUL_CLIENT_KEY\"\n\n\t// HTTPTLSServerName defines an environment variable name which sets the\n\t// server name to use as the SNI host when connecting via TLS\n\tHTTPTLSServerName = \"CONSUL_TLS_SERVER_NAME\"\n\n\t// HTTPSSLVerifyEnvName defines an environment variable name which sets\n\t//",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fapi.go",
    "is_test_file": false
  },
  "api/api_test.go": {
    "status": "modified",
    "patch": "@@ -719,8 +719,7 @@ func TestAPI_ClientTLSOptions(t *testing.T) {\n \t\t_, err = client.Agent().Self()\n \t\t// Check for one of the possible cert error messages\n \t\t// See https://cs.opensource.google/go/go/+/62a994837a57a7d0c58bb364b580a389488446c9\n-\t\tif err == nil || !(strings.Contains(err.Error(), \"tls: bad certificate\") ||\n-\t\t\tstrings.Contains(err.Error(), \"tls: certificate required\")) {\n+\t\tif err == nil || (!strings.Contains(err.Error(), \"tls: bad certificate\") && !strings.Contains(err.Error(), \"tls: certificate required\")) {\n \t\t\tt.Fatalf(\"expected tls certificate error, but got '%v'\", err)\n \t\t}\n \t})",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\ntype configCallback func(c *Config)\n\nfunc makeClient(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, nil, nil)\n}\n\nfunc makeClientWithoutConnect(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, nil, func(serverConfig *testutil.TestServerConfig) {\n\t\tserverConfig.Connect = nil\n\t})\n}\n\nfunc makeACLClient(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, func(clientConfig *Config) {\n\t\tclientConfig.Token = \"root\"\n\t}, func(serverConfig *testutil.TestServerConfig) {\n\t\tserverConfig.PrimaryDatacenter = \"dc1\"\n\t\tserverConfig.ACL.Tokens.InitialManagement = \"root\"\n\t\tserverConfig.ACL.Tokens.Agent = \"root\"\n\t\tserverConfig.ACL.Enabled = true\n\t\tserverConfig.ACL.DefaultPolicy = \"deny\"\n\t})\n}\n\n// Makes a client with Audit enabled, it requires ACLs\nfunc makeAuditClient(t *testing.T) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t, func(clientConfig *Config) {\n\t\tclientConfig.Token = \"root\"\n\t}, func(serverConfig *testutil.TestServerConfig) {\n\t\tserverConfig.PrimaryDatacenter = \"dc1\"\n\t\tserverConfig.ACL.Tokens.InitialManagement = \"root\"\n\t\tserverConfig.ACL.Tokens.Agent = \"root\"\n\t\tserverConfig.ACL.Enabled = true\n\t\tserverConfig.ACL.DefaultPolicy = \"deny\"\n\t\tserverConfig.Audit = &testutil.TestAuditConfig{\n\t\t\tEnabled: true,\n\t\t}\n\t})\n}\n\nfunc makeNonBootstrappedACLClient(t *testing.T, defaultPolicy string) (*Client, *testutil.TestServer) {\n\treturn makeClientWithConfig(t,\n\t\tfunc(clientConfig *Con",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fapi_test.go",
    "is_test_file": true
  },
  "api/catalog_test.go": {
    "status": "modified",
    "patch": "@@ -321,7 +321,7 @@ func TestAPI_CatalogServiceUnmanagedProxy(t *testing.T) {\n \n \tcatalog := c.Catalog()\n \n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \n \tretry.Run(t, func(r *retry.R) {\n \t\t_, err := catalog.Register(proxyReg, nil)\n@@ -530,7 +530,7 @@ func TestAPI_CatalogService_Filter(t *testing.T) {\n \n }\n \n-func testUpstreams(t *testing.T) []Upstream {\n+func testUpstreams() []Upstream {\n \treturn []Upstream{\n \t\t{\n \t\t\tDestinationName: \"db\",\n@@ -547,29 +547,17 @@ func testUpstreams(t *testing.T) []Upstream {\n \t}\n }\n \n-func testExpectUpstreamsWithDefaults(t *testing.T, upstreams []Upstream) []Upstream {\n-\tups := make([]Upstream, len(upstreams))\n-\tfor i := range upstreams {\n-\t\tups[i] = upstreams[i]\n-\t\t// Fill in default fields we expect to have back explicitly in a response\n-\t\tif ups[i].DestinationType == \"\" {\n-\t\t\tups[i].DestinationType = UpstreamDestTypeService\n-\t\t}\n-\t}\n-\treturn ups\n-}\n-\n // testUnmanagedProxy returns a fully configured external proxy service suitable\n // for checking that all the config fields make it back in a response intact.\n-func testUnmanagedProxy(t *testing.T) *AgentService {\n+func testUnmanagedProxy() *AgentService {\n \treturn &AgentService{\n \t\tKind: ServiceKindConnectProxy,\n \t\tProxy: &AgentServiceConnectProxyConfig{\n \t\t\tDestinationServiceName: \"web\",\n \t\t\tDestinationServiceID:   \"web1\",\n \t\t\tLocalServiceAddress:    \"127.0.0.2\",\n \t\t\tLocalServicePort:       8080,\n-\t\t\tUpstreams:              testUpstreams(t),\n+\t\t\tUpstreams:              testUpstreams(),\n \t\t\tMode:                   ProxyModeTransparent,\n \t\t\tTransparentProxy: &TransparentProxyConfig{\n \t\t\t\tOutboundListenerPort: 808,\n@@ -583,12 +571,12 @@ func testUnmanagedProxy(t *testing.T) *AgentService {\n \n // testUnmanagedProxyRegistration returns a *CatalogRegistration for a fully\n // configured external proxy.\n-func testUnmanagedProxyRegistration(t *testing.T) *CatalogRegistration {\n+func testUnmanagedProxyRegistration() *CatalogRegistration {\n \treturn &CatalogRegistration{\n \t\tDatacenter: \"dc1\",\n \t\tNode:       \"foobar\",\n \t\tAddress:    \"192.168.10.10\",\n-\t\tService:    testUnmanagedProxy(t),\n+\t\tService:    testUnmanagedProxy(),\n \t}\n }\n \n@@ -600,7 +588,7 @@ func TestAPI_CatalogConnect(t *testing.T) {\n \tcatalog := c.Catalog()\n \n \t// Register service and proxy instances to test against.\n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \n \tproxy := proxyReg.Service\n \n@@ -755,7 +743,7 @@ func TestAPI_CatalogNode(t *testing.T) {\n \tname, err := c.Agent().NodeName()\n \trequire.NoError(t, err)\n \n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \tproxyReg.Node = name\n \tproxyReg.SkipNodeUpdate = true\n \n@@ -806,7 +794,7 @@ func TestAPI_CatalogNodeServiceList(t *testing.T) {\n \tname, err := c.Agent().NodeName()\n \trequire.NoError(t, err)\n \n-\tproxyReg := testUnmanagedProxyRegistration(t)\n+\tproxyReg := testUnmanagedProxyRegistration()\n \tproxyReg.Node = name\n \tproxyReg.SkipNodeUpdate = true\n ",
    "additions": 9,
    "deletions": 21,
    "changes": 30,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n\t\"github.com/hashicorp/consul/sdk/testutil/retry\"\n)\n\nfunc TestAPI_CatalogDatacenters(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tcatalog := c.Catalog()\n\tretry.Run(t, func(r *retry.R) {\n\t\tdatacenters, err := catalog.Datacenters()\n\t\tif err != nil {\n\t\t\tr.Fatal(err)\n\t\t}\n\t\tif len(datacenters) < 1 {\n\t\t\tr.Fatal(\"got 0 datacenters want at least one\")\n\t\t}\n\t})\n}\n\nfunc TestAPI_CatalogNodes(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\ts.WaitForSerfCheck(t)\n\tcatalog := c.Catalog()\n\n\tretry.Run(t, func(r *retry.R) {\n\t\tnodes, meta, err := catalog.Nodes(nil)\n\t\trequire.NoError(r, err)\n\t\trequire.Len(r, nodes, 1)\n\t\trequire.True(r, meta.LastIndex >= 1, \"Last index must be greater than 1\")\n\n\t\t// The raft indexes are not relevant for this test.\n\t\tgot := nodes[0]\n\t\tgot.CreateIndex = 0\n\t\tgot.ModifyIndex = 0\n\n\t\twant := &Node{\n\t\t\tID:         s.Config.NodeID,\n\t\t\tNode:       s.Config.NodeName,\n\t\t\tPartition:  defaultPartition,\n\t\t\tAddress:    \"127.0.0.1\",\n\t\t\tDatacenter: \"dc1\",\n\t\t\tTaggedAddresses: map[string]string{\n\t\t\t\t\"lan\":      \"127.0.0.1\",\n\t\t\t\t\"lan_ipv4\": \"127.0.0.1\",\n\t\t\t\t\"wan\":      \"127.0.0.1\",\n\t\t\t\t\"wan_ipv4\": \"127.0.0.1\",\n\t\t\t},\n\t\t\tMeta: map[string]string{\n\t\t\t\t\"consul-network-segment\": \"\",\n\t\t\t\t\"consul-version\":         s.Config.Version,\n\t\t\t},\n\t\t}\n\t\trequire.Equal(r, want, got)\n\t})\n}\n\nfunc TestAPI_CatalogNodes_MetaFilter(t *testing.T) {\n\tt.Parallel()\n\tmeta := map[string]string{\"somekey\": \"somevalue\"}\n\tc, s := makeClientWithConfig(t, nil, func(conf *testutil.TestServerConfig) {\n\t\tconf.NodeMeta = meta\n\t})\n\tdefer s.Stop()\n\n\tcatalog := c.Catalog()\n\t// Make sure we get the node back when filtering by its metadata\n\tretry.Run(t, func(r *retry.R) {\n\t\tnodes, meta, err := catalog.Nodes(&QueryOptions{NodeMeta: ",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fcatalog_test.go",
    "is_test_file": true
  },
  "api/mock_api_test.go": {
    "status": "modified",
    "patch": "@@ -26,7 +26,7 @@ func setupMockAPI(t *testing.T) (*mockAPI, *Client) {\n \tmapi.ts = httptest.NewServer(&mapi)\n \tt.Cleanup(func() {\n \t\tmapi.ts.Close()\n-\t\tmapi.Mock.AssertExpectations(t)\n+\t\tmapi.AssertExpectations(t)\n \t})\n \n \tcfg := DefaultConfig()",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype mockAPI struct {\n\tts *httptest.Server\n\tt  *testing.T\n\tmock.Mock\n}\n\nfunc setupMockAPI(t *testing.T) (*mockAPI, *Client) {\n\tmapi := mockAPI{t: t}\n\tmapi.Test(t)\n\tmapi.ts = httptest.NewServer(&mapi)\n\tt.Cleanup(func() {\n\t\tmapi.ts.Close()\n\t\tmapi.AssertExpectations(t)\n\t})\n\n\tcfg := DefaultConfig()\n\tcfg.Address = mapi.ts.URL\n\n\tclient, err := NewClient(cfg)\n\trequire.NoError(t, err)\n\treturn &mapi, client\n}\n\nfunc (m *mockAPI) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar body interface{}\n\n\tif r.Body != nil {\n\t\tbodyBytes, err := io.ReadAll(r.Body)\n\t\tif err == nil && len(bodyBytes) > 0 {\n\t\t\tbody = bodyBytes\n\n\t\t\tvar bodyMap map[string]interface{}\n\t\t\tif err := json.Unmarshal(bodyBytes, &bodyMap); err != nil {\n\t\t\t\tbody = bodyMap\n\t\t\t}\n\t\t}\n\t}\n\n\tret := m.Called(r.Method, r.URL.Path, body)\n\n\tif replyFn, ok := ret.Get(0).(func(http.ResponseWriter, *http.Request)); ok {\n\t\treplyFn(w, r)\n\t\treturn\n\t}\n}\n\nfunc (m *mockAPI) static(method string, path string, body interface{}) *mock.Call {\n\treturn m.On(\"ServeHTTP\", method, path, body)\n}\n\nfunc (m *mockAPI) withReply(method, path string, body interface{}, status int, reply interface{}) *mock.Call {\n\treturn m.static(method, path, body).Return(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(status)\n\n\t\tif reply == nil {\n\t\t\treturn\n\t\t}\n\n\t\trdr, ok := reply.(io.Reader)\n\t\tif ok {\n\t\t\tio.Copy(w, rdr)\n\t\t\treturn\n\t\t}\n\n\t\tenc := json.NewEncoder(w)\n\t\trequire.NoError(m.t, enc.Encode(reply))\n\t})\n}\n",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fmock_api_test.go",
    "is_test_file": true
  },
  "api/namespace.go": {
    "status": "modified",
    "patch": "@@ -85,14 +85,10 @@ func (n *NamespaceACLConfig) UnmarshalJSON(data []byte) error {\n \t}\n \n \tif n.PolicyDefaults == nil {\n-\t\tfor _, pd := range aux.PolicyDefaultsSnake {\n-\t\t\tn.PolicyDefaults = append(n.PolicyDefaults, pd)\n-\t\t}\n+\t\tn.PolicyDefaults = append(n.PolicyDefaults, aux.PolicyDefaultsSnake...)\n \t}\n \tif n.RoleDefaults == nil {\n-\t\tfor _, pd := range aux.RoleDefaultsSnake {\n-\t\t\tn.RoleDefaults = append(n.RoleDefaults, pd)\n-\t\t}\n+\t\tn.RoleDefaults = append(n.RoleDefaults, aux.RoleDefaultsSnake...)\n \t}\n \treturn nil\n }",
    "additions": 2,
    "deletions": 6,
    "changes": 8,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Namespace is the configuration of a single namespace. Namespacing is a Consul Enterprise feature.\ntype Namespace struct {\n\t// Name is the name of the Namespace. It must be unique and\n\t// must be a DNS hostname. There are also other reserved names\n\t// that may not be used.\n\tName string `json:\"Name\"`\n\n\t// Description is where the user puts any information they want\n\t// about the namespace. It is not used internally.\n\tDescription string `json:\"Description,omitempty\"`\n\n\t// ACLs is the configuration of ACLs for this namespace. It has its\n\t// own struct so that we can add more to it in the future.\n\t// This is nullable so that we can omit if empty when encoding in JSON\n\tACLs *NamespaceACLConfig `json:\"ACLs,omitempty\"`\n\n\t// Meta is a map that can be used to add kv metadata to the namespace definition\n\tMeta map[string]string `json:\"Meta,omitempty\"`\n\n\t// DeletedAt is the time when the Namespace was marked for deletion\n\t// This is nullable so that we can omit if empty when encoding in JSON\n\tDeletedAt *time.Time `json:\"DeletedAt,omitempty\" alias:\"deleted_at\"`\n\n\t// Partition which contains the Namespace.\n\tPartition string `json:\"Partition,omitempty\"`\n\n\t// CreateIndex is the Raft index at which the Namespace was created\n\tCreateIndex uint64 `json:\"CreateIndex,omitempty\"`\n\n\t// ModifyIndex is the latest Raft index at which the Namespace was modified.\n\tModifyIndex uint64 `json:\"ModifyIndex,omitempty\"`\n}\n\nfunc (n *Namespace) UnmarshalJSON(data []byte) error {\n\ttype Alias Namespace\n\taux := struct {\n\t\tDeletedAtSnake *time.Time `json:\"deleted_at\"`\n\t\t*Alias\n\t}{\n\t\tAlias: (*Alias)(n),\n\t}\n\tif err := json.Unmarshal(data, &aux); err != nil {\n\t\treturn err\n\t}\n\n\tif n.DeletedAt == nil && aux.DeletedAtSnake != nil {\n\t\tn.DeletedAt = aux.DeletedAtSnake\n\t}\n\n\treturn nil\n}\n\n// NamespaceACLConfig is the Namespace specific ACL configuration container\ntype NamespaceACLConfig str",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fnamespace.go",
    "is_test_file": false
  },
  "api/peering.go": {
    "status": "modified",
    "patch": "@@ -218,7 +218,7 @@ func (p *Peerings) GenerateToken(ctx context.Context, g PeeringGenerateTokenRequ\n \t\treturn nil, nil, fmt.Errorf(\"peer name cannot be empty\")\n \t}\n \n-\treq := p.c.newRequest(\"POST\", fmt.Sprint(\"/v1/peering/token\"))\n+\treq := p.c.newRequest(\"POST\", \"/v1/peering/token\")\n \treq.setWriteOptions(wq)\n \treq.ctx = ctx\n \treq.obj = g\n@@ -244,7 +244,7 @@ func (p *Peerings) GenerateToken(ctx context.Context, g PeeringGenerateTokenRequ\n \n // TODO(peering): verify this is the ultimate signature we want\n func (p *Peerings) Establish(ctx context.Context, i PeeringEstablishRequest, wq *WriteOptions) (*PeeringEstablishResponse, *WriteMeta, error) {\n-\treq := p.c.newRequest(\"POST\", fmt.Sprint(\"/v1/peering/establish\"))\n+\treq := p.c.newRequest(\"POST\", \"/v1/peering/establish\")\n \treq.setWriteOptions(wq)\n \treq.ctx = ctx\n \treq.obj = i",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// PeeringState enumerates all the states a peering can be in\ntype PeeringState string\n\nconst (\n\t// PeeringStateUndefined represents an unset value for PeeringState during\n\t// writes.\n\tPeeringStateUndefined PeeringState = \"UNDEFINED\"\n\n\t// PeeringStatePending means the peering was created by generating a peering token.\n\t// Peerings stay in a pending state until the peer uses the token to dial\n\t// the local cluster.\n\tPeeringStatePending PeeringState = \"PENDING\"\n\n\t// PeeringStateEstablishing means the peering is being established from a peering token.\n\t// This is the initial state for dialing peers.\n\tPeeringStateEstablishing PeeringState = \"ESTABLISHING\"\n\n\t// PeeringStateActive means that the peering connection is active and\n\t// healthy.\n\tPeeringStateActive PeeringState = \"ACTIVE\"\n\n\t// PeeringStateFailing means the peering connection has been interrupted\n\t// but has not yet been terminated.\n\tPeeringStateFailing PeeringState = \"FAILING\"\n\n\t// PeeringStateDeleting means a peering was marked for deletion and is in the process\n\t// of being deleted.\n\tPeeringStateDeleting PeeringState = \"DELETING\"\n\n\t// PeeringStateTerminated means the peering relationship has been removed.\n\tPeeringStateTerminated PeeringState = \"TERMINATED\"\n)\n\ntype PeeringRemoteInfo struct {\n\t// Partition is the remote peer's partition.\n\tPartition string\n\t// Datacenter is the remote peer's datacenter.\n\tDatacenter string\n\tLocality   *Locality `json:\",omitempty\"`\n}\n\n// Locality identifies where a given entity is running.\ntype Locality struct {\n\t// Region is region the zone belongs to.\n\tRegion string\n\n\t// Zone is the zone the entity is running in.\n\tZone string\n}\n\ntype Peering struct {\n\t// ID is a datacenter-scoped UUID for the peering.\n\tID string\n\t// Name is the local alias for the peering relationship.\n\tName string\n\t// Partition is the local partition connecting to the peer.\n\tPartition string",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fpeering.go",
    "is_test_file": false
  },
  "api/raw_test.go": {
    "status": "modified",
    "patch": "@@ -4,7 +4,6 @@\n package api\n \n import (\n-\t\"fmt\"\n \t\"strings\"\n \t\"testing\"\n \n@@ -34,7 +33,7 @@ func TestAPI_RawV2ExportedServices(t *testing.T) {\n \n \tdefer s.Stop()\n \n-\tendpoint := strings.ToLower(fmt.Sprintf(\"/api/multicluster/v2/exportedservices/e1\"))\n+\tendpoint := strings.ToLower(\"/api/multicluster/v2/exportedservices/e1\")\n \twResp := &V2WriteResponse{}\n \n \twReq := &V2WriteRequest{",
    "additions": 1,
    "deletions": 2,
    "changes": 3,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage api\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n)\n\ntype V2WriteRequest struct {\n\tData map[string]any `json:\"data\"`\n}\n\ntype V2WriteResponse struct {\n\tID struct {\n\t\tName string `json:\"name\"`\n\t} `json:\"id\"`\n\tData map[string]any `json:\"data\"`\n}\n\n// We are testing a v2 endpoint here in the v1 api module as a temporary measure to\n// support v2 CRUD operations, until we have a final design for v2 api clients.\nfunc TestAPI_RawV2ExportedServices(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClientWithConfig(t, nil, func(conf *testutil.TestServerConfig) {\n\t\tconf.EnableDebug = true\n\t})\n\n\tdefer s.Stop()\n\n\tendpoint := strings.ToLower(\"/api/multicluster/v2/exportedservices/e1\")\n\twResp := &V2WriteResponse{}\n\n\twReq := &V2WriteRequest{\n\t\tData: map[string]any{\n\t\t\t\"consumers\": []map[string]any{\n\t\t\t\t{\"peer\": \"p1\"},\n\t\t\t},\n\t\t\t\"services\": []string{\"s1\"},\n\t\t},\n\t}\n\n\t_, err := c.Raw().Write(endpoint, wReq, wResp, &WriteOptions{Datacenter: \"dc1\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, wResp.ID.Name)\n\n\tqOpts := &QueryOptions{Datacenter: \"dc1\"}\n\n\tvar out map[string]interface{}\n\t_, err = c.Raw().Query(endpoint, &out, qOpts)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, map[string]any{\n\t\t\"consumers\": []any{\n\t\t\tmap[string]any{\"peer\": \"p1\"},\n\t\t},\n\t\t\"services\": []any{\"s1\"},\n\t}, out[\"data\"])\n\n\t_, err = c.Raw().Delete(endpoint, qOpts)\n\trequire.NoError(t, err)\n\n\tout = make(map[string]interface{})\n\t_, err = c.Raw().Query(endpoint, &out, qOpts)\n\trequire.ErrorContains(t, err, \"404\")\n}\n",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fraw_test.go",
    "is_test_file": true
  },
  "api/watch/watch.go": {
    "status": "modified",
    "patch": "@@ -244,18 +244,18 @@ func assignValueBool(params map[string]interface{}, name string, out *bool) erro\n func assignValueStringSlice(params map[string]interface{}, name string, out *[]string) error {\n \tif raw, ok := params[name]; ok {\n \t\tvar tmp []string\n-\t\tswitch raw.(type) {\n+\t\tswitch raw := raw.(type) {\n \t\tcase string:\n-\t\t\ttmp = make([]string, 1, 1)\n-\t\t\ttmp[0] = raw.(string)\n+\t\t\ttmp = make([]string, 1)\n+\t\t\ttmp[0] = raw\n \t\tcase []string:\n-\t\t\tl := len(raw.([]string))\n-\t\t\ttmp = make([]string, l, l)\n-\t\t\tcopy(tmp, raw.([]string))\n+\t\t\tl := len(raw)\n+\t\t\ttmp = make([]string, l)\n+\t\t\tcopy(tmp, raw)\n \t\tcase []interface{}:\n-\t\t\tl := len(raw.([]interface{}))\n-\t\t\ttmp = make([]string, l, l)\n-\t\t\tfor i, v := range raw.([]interface{}) {\n+\t\t\tl := len(raw)\n+\t\t\ttmp = make([]string, l)\n+\t\t\tfor i, v := range raw {\n \t\t\t\tif s, ok := v.(string); ok {\n \t\t\t\t\ttmp[i] = s\n \t\t\t\t} else {",
    "additions": 9,
    "deletions": 9,
    "changes": 18,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: MPL-2.0\n\npackage watch\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\tconsulapi \"github.com/hashicorp/consul/api\"\n\t\"github.com/hashicorp/go-hclog\"\n\t\"github.com/mitchellh/mapstructure\"\n)\n\nconst DefaultTimeout = 10 * time.Second\n\n// Plan is the parsed version of a watch specification. A watch provides\n// the details of a query, which generates a view into the Consul data store.\n// This view is watched for changes and a handler is invoked to take any\n// appropriate actions.\ntype Plan struct {\n\tDatacenter  string\n\tToken       string\n\tType        string\n\tHandlerType string\n\tExempt      map[string]interface{}\n\n\tWatcher WatcherFunc\n\t// Handler is kept for backward compatibility but only supports watches based\n\t// on index param. To support hash based watches, set HybridHandler instead.\n\tHandler       HandlerFunc\n\tHybridHandler HybridHandlerFunc\n\n\tLogger hclog.Logger\n\t// Deprecated: use Logger\n\tLogOutput io.Writer\n\n\taddress      string\n\tclient       *consulapi.Client\n\tlastParamVal BlockingParamVal\n\tlastResult   interface{}\n\n\tstop       bool\n\tstopCh     chan struct{}\n\tstopLock   sync.Mutex\n\tcancelFunc context.CancelFunc\n}\n\ntype HttpHandlerConfig struct {\n\tPath          string              `mapstructure:\"path\"`\n\tMethod        string              `mapstructure:\"method\"`\n\tTimeout       time.Duration       `mapstructure:\"-\"`\n\tTimeoutRaw    string              `mapstructure:\"timeout\"`\n\tHeader        map[string][]string `mapstructure:\"header\"`\n\tTLSSkipVerify bool                `mapstructure:\"tls_skip_verify\"`\n}\n\n// BlockingParamVal is an interface representing the common operations needed for\n// different styles of blocking. It's used to abstract the core watch plan from\n// whether we are performing index-based or hash-based blocking.\ntype BlockingParamVal interface {\n\t// Equal returns whether the other param value should be considered equal\n\t// (i.e. representing no change in the watched resource). Equal must not ",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/api%2Fwatch%2Fwatch.go",
    "is_test_file": false
  },
  "build-support/scripts/devtools.sh": {
    "status": "modified",
    "patch": "@@ -164,9 +164,9 @@ function lint_install {\n \n     install_versioned_tool \\\n         'golangci-lint' \\\n-        'github.com/golangci/golangci-lint' \\\n+        'github.com/golangci/golangci-lint/v2' \\\n         \"${golangci_lint_version}\" \\\n-        'github.com/golangci/golangci-lint/cmd/golangci-lint'\n+        'github.com/golangci/golangci-lint/v2/cmd/golangci-lint'\n \n     install_versioned_tool \\\n         'gci' \\",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "language": "sh",
    "imports": [],
    "full_content": "#!/usr/bin/env bash\n# Copyright (c) HashiCorp, Inc.\n# SPDX-License-Identifier: BUSL-1.1\n\n\nreadonly SCRIPT_NAME=\"$(basename ${BASH_SOURCE[0]})\"\nreadonly SCRIPT_DIR=\"$(dirname \"${BASH_SOURCE[0]}\")\"\nreadonly SOURCE_DIR=\"$(dirname \"$(dirname \"${SCRIPT_DIR}\")\")\"\nreadonly FN_DIR=\"$(dirname \"${SCRIPT_DIR}\")/functions\"\n\nsource \"${SCRIPT_DIR}/functions.sh\"\n\nunset CDPATH\n\nset -euo pipefail\n\nusage() {\ncat <<-EOF\nUsage: ${SCRIPT_NAME} [<options ...>]\n\nDescription:\n    Installs various supporting Go tools.\n\nOptions:\n    -protobuf                Just install tools for protobuf.\n    -lint                    Just install tools for linting.\n    -codegen                 Just install tools for codegen.\n    -pre-commit              Just install pre-commit.\n    -h | --help              Print this help text.\nEOF\n}\n\nfunction err_usage {\n    err \"$1\"\n    err \"\"\n    err \"$(usage)\"\n}\n\nfunction main {\n    while test $# -gt 0\n    do\n        case \"$1\" in\n            -protobuf )\n                proto_tools_install\n                return 0\n                ;;\n            -lint )\n                lint_install\n                return 0\n                ;;\n            -codegen )\n                codegen_install\n                return 0\n                ;;\n            -pre-commit )\n                pre_commit_install\n                return 0\n                ;;\n            -h | --help )\n                usage\n                return 0\n                ;;\n        esac\n    done\n\n    # ensure these tools are installed\n    tools_install\n}\n\nfunction proto_tools_install {\n    local protoc_gen_go_version\n    local protoc_gen_go_grpc_version\n    local buf_version\n    local mog_version\n    local protoc_go_inject_tag_version\n    local mockery_version\n\n    mockery_version=\"$(make --no-print-directory print-MOCKERY_VERSION)\"\n    protoc_gen_go_version=\"$(grep google.golang.org/protobuf go.mod | awk '{print $2}')\"\n    protoc_gen_go_grpc_version=\"$(make --no-print-directory print-PROTOC_GEN_GO_GRPC_VERSION)\"\n    mog_version=\"",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/build-support%2Fscripts%2Fdevtools.sh",
    "is_test_file": false
  },
  "command/snapshot/inspect/formatter.go": {
    "status": "modified",
    "patch": "@@ -41,7 +41,7 @@ func NewFormatter(format string) (Formatter, error) {\n \t}\n }\n \n-func (_ *prettyFormatter) Format(info *OutputFormat) (string, error) {\n+func (*prettyFormatter) Format(info *OutputFormat) (string, error) {\n \tvar b bytes.Buffer\n \ttw := tabwriter.NewWriter(&b, 8, 8, 6, ' ', 0)\n \n@@ -85,7 +85,7 @@ func newJSONFormatter() Formatter {\n \treturn &jsonFormatter{}\n }\n \n-func (_ *jsonFormatter) Format(info *OutputFormat) (string, error) {\n+func (*jsonFormatter) Format(info *OutputFormat) (string, error) {\n \tb, err := json.MarshalIndent(info, \"\", \"   \")\n \tif err != nil {\n \t\treturn \"\", fmt.Errorf(\"Failed to marshal original snapshot stats: %v\", err)",
    "additions": 2,
    "deletions": 2,
    "changes": 4,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage inspect\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/tabwriter\"\n)\n\nconst (\n\tPrettyFormat string = \"pretty\"\n\tJSONFormat   string = \"json\"\n)\n\ntype Formatter interface {\n\tFormat(*OutputFormat) (string, error)\n}\n\nfunc GetSupportedFormats() []string {\n\treturn []string{PrettyFormat, JSONFormat}\n}\n\ntype prettyFormatter struct{}\n\nfunc newPrettyFormatter() Formatter {\n\treturn &prettyFormatter{}\n}\nfunc NewFormatter(format string) (Formatter, error) {\n\tswitch format {\n\tcase PrettyFormat:\n\t\treturn newPrettyFormatter(), nil\n\tcase JSONFormat:\n\t\treturn newJSONFormatter(), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Unknown format: %s\", format)\n\t}\n}\n\nfunc (*prettyFormatter) Format(info *OutputFormat) (string, error) {\n\tvar b bytes.Buffer\n\ttw := tabwriter.NewWriter(&b, 8, 8, 6, ' ', 0)\n\n\tfmt.Fprintf(tw, \" ID\\t%s\", info.Meta.ID)\n\tfmt.Fprintf(tw, \"\\n Size\\t%d\", info.Meta.Size)\n\tfmt.Fprintf(tw, \"\\n Index\\t%d\", info.Meta.Index)\n\tfmt.Fprintf(tw, \"\\n Term\\t%d\", info.Meta.Term)\n\tfmt.Fprintf(tw, \"\\n Version\\t%d\", info.Meta.Version)\n\tfmt.Fprintf(tw, \"\\n\")\n\tfmt.Fprintln(tw, \"\\n Type\\tCount\\tSize\")\n\tfmt.Fprintf(tw, \" %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\t// For each different type generate new output\n\tfor _, s := range info.Stats {\n\t\tfmt.Fprintf(tw, \"\\n %s\\t%d\\t%s\", s.Name, s.Count, ByteSize(uint64(s.Sum)))\n\t}\n\tfmt.Fprintf(tw, \"\\n %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\tfmt.Fprintf(tw, \"\\n Total\\t\\t%s\", ByteSize(uint64(info.TotalSize)))\n\n\tif info.StatsKV != nil {\n\t\tfmt.Fprintf(tw, \"\\n\")\n\t\tfmt.Fprintln(tw, \"\\n Key Name\\tCount\\tSize\")\n\t\tfmt.Fprintf(tw, \" %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\t\t// For each different type generate new output\n\t\tfor _, s := range info.StatsKV {\n\t\t\tfmt.Fprintf(tw, \"\\n %s\\t%d\\t%s\", s.Name, s.Count, ByteSize(uint64(s.Sum)))\n\t\t}\n\t\tfmt.Fprintf(tw, \"\\n %s\\t%s\\t%s\", \"----\", \"----\", \"----\")\n\t\tfmt.Fprintf(tw, \"\\n Total\\t\\t%s\", ByteSize(uint64(info.TotalSizeKV)))\n\t}\n\n\tif err := ",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/command%2Fsnapshot%2Finspect%2Fformatter.go",
    "is_test_file": true
  },
  "envoyextensions/extensioncommon/resources_test.go": {
    "status": "modified",
    "patch": "@@ -20,46 +20,46 @@ func TestInsertHTTPFilter(t *testing.T) {\n \t\terrStr          string\n \t}{\n \t\t\"insert first\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertFirst},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert last\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertLast},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n \t\t},\n \t\t\"insert before first match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after first match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert before last match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after last match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n \t\t},\n \t\t\"insert last after last match\": {\n-\t\t\tinputFilters:    makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterLastMatch, FilterName: \"c\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeHttpFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n+\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n \t\t},\n \t}\n \n@@ -95,40 +95,40 @@ func TestInsertFilter(t *testing.T) {\n \t\terrStr          string\n \t}{\n \t\t\"insert first\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertFirst},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert last\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertLast},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n \t\t},\n \t\t\"insert before first match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after first match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterFirstMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert before last match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"b\", \"test.filter\", \"b\", \"c\"),\n \t\t},\n \t\t\"insert after last match\": {\n-\t\t\tinputFilters:    makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"c\"),\n+\t\t\tinputFilters:    makeFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n \t\t\tinsertOptions:   InsertOptions{Location: InsertAfterLastMatch, FilterName: \"b\"},\n \t\t\tfilterName:      \"test.filter\",\n-\t\t\texpectedFilters: makeFilters(t, \"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n+\t\t\texpectedFilters: makeFilters(\"a\", \"b\", \"b\", \"b\", \"test.filter\", \"c\"),\n \t\t},\n \t}\n \n@@ -158,15 +158,15 @@ func makeHttpConMgr(t *testing.T, filters []*envoy_http_v3.HttpFilter) *envoy_li\n \treturn filter\n }\n \n-func makeHttpFilters(t *testing.T, names ...string) []*envoy_http_v3.HttpFilter {\n+func makeHttpFilters(names ...string) []*envoy_http_v3.HttpFilter {\n \tvar filters []*envoy_http_v3.HttpFilter\n \tfor _, name := range names {\n \t\tfilters = append(filters, &envoy_http_v3.HttpFilter{Name: name})\n \t}\n \treturn filters\n }\n \n-func makeFilters(t *testing.T, names ...string) []*envoy_listener_v3.Filter {\n+func makeFilters(names ...string) []*envoy_listener_v3.Filter {\n \tvar filters []*envoy_listener_v3.Filter\n \tfor _, name := range names {\n \t\tfilters = append(filters, &envoy_listener_v3.Filter{Name: name})",
    "additions": 28,
    "deletions": 28,
    "changes": 56,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage extensioncommon\n\nimport (\n\t\"testing\"\n\n\tenvoy_listener_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"\n\tenvoy_http_v3 \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestInsertHTTPFilter(t *testing.T) {\n\tcases := map[string]struct {\n\t\tinputFilters    []*envoy_http_v3.HttpFilter\n\t\tinsertOptions   InsertOptions\n\t\tfilterName      string\n\t\texpectedFilters []*envoy_http_v3.HttpFilter\n\t\terrStr          string\n\t}{\n\t\t\"insert first\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertFirst},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"test.filter\", \"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t},\n\t\t\"insert last\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertLast},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\", \"test.filter\"),\n\t\t},\n\t\t\"insert before first match\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeFirstMatch, FilterName: \"b\"},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"test.filter\", \"b\", \"b\", \"b\", \"c\"),\n\t\t},\n\t\t\"insert after first match\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertAfterFirstMatch, FilterName: \"b\"},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"test.filter\", \"b\", \"b\", \"c\"),\n\t\t},\n\t\t\"insert before last match\": {\n\t\t\tinputFilters:    makeHttpFilters(\"a\", \"b\", \"b\", \"b\", \"c\"),\n\t\t\tinsertOptions:   InsertOptions{Location: InsertBeforeLastMatch, FilterName: \"b\"},\n\t\t\tfilterName:      \"test.filter\",\n\t\t\texpectedFilters: makeHttpFilters(\"a\", \"b\", \"b\", \"test.filter\", \"b\",",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/envoyextensions%2Fextensioncommon%2Fresources_test.go",
    "is_test_file": true
  },
  "internal/resource/http/http_test.go": {
    "status": "modified",
    "patch": "@@ -56,7 +56,7 @@ func TestResourceHandler_InputValidation(t *testing.T) {\n \t\t\tScope: resource.ScopeNamespace,\n \t\t},\n \t\tclient,\n-\t\tfunc(req *http.Request, token *string) { return },\n+\t\tfunc(req *http.Request, token *string) {},\n \t\thclog.NewNullLogger(),\n \t}\n ",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "language": "go",
    "imports": [],
    "full_content": "// Copyright (c) HashiCorp, Inc.\n// SPDX-License-Identifier: BUSL-1.1\n\npackage http\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/hashicorp/go-hclog\"\n\n\tsvc \"github.com/hashicorp/consul/agent/grpc-external/services/resource\"\n\tsvctest \"github.com/hashicorp/consul/agent/grpc-external/services/resource/testing\"\n\t\"github.com/hashicorp/consul/internal/resource\"\n\t\"github.com/hashicorp/consul/internal/resource/demo\"\n\t\"github.com/hashicorp/consul/proto-public/pbresource\"\n\tpbdemov1 \"github.com/hashicorp/consul/proto/private/pbdemo/v1\"\n\tpbdemov2 \"github.com/hashicorp/consul/proto/private/pbdemo/v2\"\n\t\"github.com/hashicorp/consul/sdk/testutil\"\n)\n\nconst testACLTokenArtistReadPolicy = \"00000000-0000-0000-0000-000000000001\"\nconst testACLTokenArtistWritePolicy = \"00000000-0000-0000-0000-000000000002\"\nconst testACLTokenArtistListPolicy = \"00000000-0000-0000-0000-000000000003\"\nconst fakeToken = \"fake-token\"\n\nfunc parseToken(req *http.Request, token *string) {\n\t*token = req.Header.Get(\"x-consul-token\")\n}\n\nfunc TestResourceHandler_InputValidation(t *testing.T) {\n\ttype testCase struct {\n\t\tdescription          string\n\t\trequest              *http.Request\n\t\tresponse             *httptest.ResponseRecorder\n\t\texpectedResponseCode int\n\t\tresponseBodyContains string\n\t}\n\n\tclient := svctest.NewResourceServiceBuilder().\n\t\tWithRegisterFns(demo.RegisterTypes).\n\t\tRun(t)\n\n\tresourceHandler := resourceHandler{\n\t\tresource.Registration{\n\t\t\tType:  demo.TypeV2Artist,\n\t\t\tProto: &pbdemov2.Artist{},\n\t\t\tScope: resource.ScopeNamespace,\n\t\t},\n\t\tclient,\n\t\tfunc(req *http.Request, token *string) {},\n\t\thclog.NewNullLogger(),\n\t}\n\n\ttestCases := []testCase{\n\t\t{\n\t\t\tdescription: \"missing resource name\",\n\t\t\trequest: httptest.NewRequest(\"PUT\", \"/?partition=default&peer_name=local&namespace=default\", strings.NewReader(`\n\t\t\t\t{\n\t\t\t\t\t\"metadata\": {\n\t\t\t\t\t\t\"foo\": \"bar\"\n\t\t\t\t\t},\n\t\t\t\t\t\"data\": {\n\t\t\t\t\t",
    "raw_url": "https://github.com/hashicorp/consul/raw/6fe730b23233bc6120677a6e84218a0ee5005e48/internal%2Fresource%2Fhttp%2Fhttp_test.go",
    "is_test_file": true
  }
}